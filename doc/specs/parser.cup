package compiler.syntax;

// Declaración de importaciones 
//(No modificar las proporcionadas. Se pueden agregar mas)

import java_cup.runtime.Symbol;
import java.util.*;

import es.uned.lsi.compiler.lexical.*;
import es.uned.lsi.compiler.code.*;
import es.uned.lsi.compiler.intermediate.*;
import es.uned.lsi.compiler.semantic.*;
import es.uned.lsi.compiler.semantic.symbol.*;
import es.uned.lsi.compiler.semantic.type.*;
import es.uned.lsi.compiler.syntax.*;

import compiler.CompilerContext;
import compiler.lexical.*;
import compiler.syntax.nonTerminal.*;
import compiler.semantic.*;
import compiler.semantic.symbol.*;
import compiler.semantic.type.*;
import compiler.intermediate.*;
import compiler.code.*;

import compiler.semantic.utils.*;

// Declaración del código de usuario

action code   {:
	
	SyntaxErrorManager   syntaxErrorManager   = CompilerContext.getSyntaxErrorManager();
	SemanticErrorManager semanticErrorManager = CompilerContext.getSemanticErrorManager ();
	ScopeManagerIF       scopeManager         = CompilerContext.getScopeManager ();
	FinalCodeFactoryIF   finalCodeFactory     = CompilerContext.getFinalCodeFactory ();

	// cadenas que aniadir al final  del archivo en ensamblador
	List cadenas = new ArrayList();
	// Desplazamiento con RA principal
	int despl=0;
:}	

parser code {:
	SyntaxErrorManager syntaxErrorManager = CompilerContext.getSyntaxErrorManager();
	
	public void syntax_error(Symbol symbol)
	{ 
	    Token token = (Token) symbol.value;
	    syntaxErrorManager.syntaxError ("Error sintactico", token);	    
	}
		
	public void unrecovered_syntax_error(java_cup.runtime.Symbol symbol)
	{	
	    Token token = (Token) symbol.value;
	    syntaxErrorManager.syntaxFatalError ("Error fatal", token);
	}
:}


// Declaración de terminales
terminal Token TLTRUE, TLFALSE, TLINT, TLSTRING, TIDENTIFICADOR;
terminal Token TAND, TNOT;
terminal Token TBEGIN, TEND;
terminal Token TIF, TTHEN, TELSE;
terminal Token TMODULE, TPROCEDURE, TRETURN;
terminal Token TDO, TWHILE;
terminal Token TWRITESTRING, TWRITEINT, TWRITELN;
terminal Token TBOOLEAN, TCONST, TINTEGER, TRECORD, TTYPE, TVAR;
terminal Token TPTOCOMA, TPARI, TPARD, TCOMA, TDOSPTS, TIGUAL;
terminal Token TSUMA, TDIVIDE, TASSIGN, TMENOR, TDISTINTO, TPUNTO;

// Declaración de no terminales
non terminal  		    program;
non terminal Axiom		axiom;

non terminal                 ctes;
non terminal            ctesLista;
non terminal              Cte cte;
non terminal       Token cteValor;
non terminal                tipos;
non terminal     Lista tiposLista;
non terminal      TypeRecord tipo;
non terminal       Lista registro;
non terminal      Lista regCampos;
non terminal SymbolIF regCampo;
non terminal                 vars;
non terminal            varsLista;
non terminal                  var;
non terminal        String varTipo;
non terminal                 subs;
non terminal             SubDecl subDecl;
non terminal      Lista subParams;
non terminal Lista subParamsCuerpo;
non terminal         Lista subPar;
non terminal     String subReturn;
non terminal        BloqueSentencias   sentencias;
non terminal       BloqueSentencias          sent;
non terminal      BloqueSentencias      sentAsign;
non terminal      BloqueSentencias         sentES;
non terminal    BloqueSentencias       sentReturn;
non terminal    BloqueSentencias         sentCall;
non terminal   Lista    sentCallParams;
non terminal    BloqueSentencias           sentIf;
non terminal       BloqueSentencias      sentElse;
non terminal         BloqueSentencias   sentWhile;
non terminal  Expresion expresion;
non terminal String tipoPrimitivo;
non terminal        BloqueSentencias cuerpoModulo;
non terminal         BloqueSentencias finalModulo;
non terminal    Lista varSeqDeIds;
non terminal            ntPtoComa;

// Declaración de relaciones de precedencia (de menos a más)
precedence nonassoc TMENOR, TDISTINTO;
precedence left     TSUMA;
precedence left     TDIVIDE, TAND;
precedence right    TNOT;
precedence left     TPUNTO, TPARI, TPARD;

// Declaración de reglas de producción
// El proceso de análisis ha de empezar emitiendo el mensaje 'Starting parsing...' y
// finalizar emitiendo el mensaje 'Parsing process finished' en el caso de no existir 
// ningún error no recuperable.

start with program;

program ::= 
  {: syntaxErrorManager.syntaxInfo ("Starting parsing..."); 
	
	
  :}
  axiom:ax
  {: 
  		// No modificar esta estructura, aunque se pueden añadir más acciones semánticas
  		
  		List intermediateCode = ax.getIntermediateCode ();
        finalCodeFactory.setEnvironment(CompilerContext.getExecutionEnvironment());
  		finalCodeFactory.create(intermediateCode);

  		// En caso de no comentarse las dos sentencias anteriores puede generar una excepcion
  		// en las llamadas a cupTest si el compilador no está completo. Esto es debido a que 
  		// aún no se tendrá implementada la generación de código intermedio ni final.
  		// Para la entrega final deberán descomentarse y usarse.
  		
  		syntaxErrorManager.syntaxInfo ("Parsing process ended.");
  :};


axiom ::= TMODULE TIDENTIFICADOR:id ntPtoComa {: 
            String programName = id.getLexema();
            scopeManager.openScope(programName); 
  		
            ScopeIF scope = scopeManager.getCurrentScope();

			TypeTableIF tablaTipos = scope.getTypeTable();

            // aniadimos los tipos simples
            TypeSimple tipoBooleano = new TypeSimple(scope);
            tipoBooleano.setName("BOOLEAN");
			tablaTipos.addType(tipoBooleano);

			TypeSimple tipoEntero = new TypeSimple(scope);
            tipoEntero.setName("INTEGER");
            tablaTipos.addType(tipoEntero);
            
        :} cuerpoModulo:bloque {:
            ScopeIF scope = scopeManager.getCurrentScope();

            Axiom ax = new Ax();

            for (TemporalIF temp:scope.getTemporalTable().getTemporals()) {
                if (temp instanceof Temporal) {
                    ((Temporal) temp).setAddress(despl);
                    despl = despl + 1;
                }
            }

            int bloqueMainRA = 2;

            int tam = scope.getSymbolTable().getSize() + scope.getTemporalTable().getSize() + bloqueMainRA;
            // TemporalIF temp = ax.getTemporal();

            IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scope);
            cb.addQuadruple("BEGIN", null, tam);
            cb.addQuadruples(bloque.getIntermediateCode());            
            cb.addQuadruple("HALT", null);

            // anyadimos todas las cadena al final del programa
            int i=1;
            cb.addQuadruple ("STRING", "cadena0","\"\\n\"", "");
            for (Iterator it = cadenas.iterator(); it.hasNext();i++){
                String nombre="cadena"+i;
                cb.addQuadruple ("STRING", nombre,it.next(), "");
            }

            List intermediateCode = cb.create();

            //IMPRIMIMOS CODIGO INTERMEDIO
            syntaxErrorManager.syntaxInfo("********************************************");
            syntaxErrorManager.syntaxInfo("**           CODIGO INTERMEDIO            **");
            syntaxErrorManager.syntaxInfo("********************************************");

            Iterator it = intermediateCode.iterator();
            while (it.hasNext()){
                syntaxErrorManager.syntaxInfo("** " + it.next().toString());
            }

            ax.setIntermediateCode(intermediateCode);

            RESULT = ax;
        :}
        | TMODULE error {:syntaxErrorManager.syntaxFatalError("001. No se ha especificado nombre al programa");:}
            
    ;

//
// DEFINICIÓN DE CONSTANTES
//
ctes ::= TCONST {: 
            ScopeIF scope = scopeManager.getCurrentScope();

            semanticErrorManager.semanticDebug("Analizando las constantes del ambito " + scope.getName());

        :} ctesLista  
        | /*nada*/ ;

ctesLista ::= cte ctesLista | cte;

cte ::= TIDENTIFICADOR:id TIGUAL cteValor:value {: 
            String identificador = id.getLexema();
            String valor = value.getLexema();
            
            int val;

            ScopeIF scope = scopeManager.getCurrentScope();
            SymbolTableIF symbolTable = scope.getSymbolTable();

            if (symbolTable.containsSymbol(identificador)) {
                semanticErrorManager.semanticFatalError("2. La constante "+ identificador+" en la linea: "+id.getLine()+" ya ha sido declarada");
            }

            String tipo = "BOOLEAN";

            if (valor.toUpperCase().equals("TRUE")) {
                val = 1;
            } else if (valor.toUpperCase().equals("FALSE")) {
                val = 0;
            } else { // integer
                val = Integer.parseInt(valor);
                tipo = "INTEGER";
            }

            SymbolConstant simboloCte = new SymbolConstant(scope, identificador.toUpperCase(), scopeManager.searchType(tipo), despl);
            simboloCte.setValue(val);

            symbolTable.addSymbol(identificador.toUpperCase(), simboloCte);
 
            String typeOfValue = Utilidades.getTypeOfValue(valor);

            if (typeOfValue.equals("noValidType")) {
                semanticErrorManager.semanticFatalError("La constante " + identificador + " no tiene un tipo valido");
            }
        :} ntPtoComa

    | error
            
    ;
cteValor ::= TLTRUE:bool {: RESULT=bool; :}      
            | TLFALSE:bool {: RESULT=bool; :} 
            | TLINT:entero {: RESULT=entero; :} 
    ;

//
// DEFINICIÓN DE TIPOS
//
tipos ::= TTYPE {:
            ScopeIF scope = scopeManager.getCurrentScope();

            semanticErrorManager.semanticDebug("Analizando los tipos del ambito " + scope.getName());

        :} tiposLista 
        | /*nada*/
	;

tiposLista ::= tipo tiposLista
        | //nada
	;

tipo ::= TIDENTIFICADOR:id TIGUAL registro:lista {: //aqui registramos el tipo
            String identificador = id.getLexema();

            ScopeIF scope = scopeManager.getCurrentScope();
			TypeTableIF tablaTipos = scope.getTypeTable();

            if (scopeManager.containsType(identificador.toUpperCase())) {
                semanticErrorManager.semanticFatalError("210. El tipo: " + identificador + " en [" + id.getLine() + ":" + id.getColumn() + "] ya ha sido definida.");
            }

            TypeRecord tipoRegistro = new TypeRecord(scope, identificador.toUpperCase());

            for(int i = 0; i < lista.size(); i++) {
                SymbolIF campo = (SymbolIF) lista.get(i);

                tipoRegistro.getTablaCampos().put(campo.getName().toUpperCase(), campo);
            }

            tablaTipos.addType(tipoRegistro);
        :} ntPtoComa
        | error
            
    ;

registro ::= TRECORD regCampos:lista {: 
            RESULT = lista; 
        :} TEND
            
        | error
            
    ;
regCampos ::= regCampo:reg regCampos:lista {:
                lista.add(reg);
                RESULT = lista;
            :}
            
        | regCampo:reg {:
            Lista lista = new Lista();
            lista.add(reg);
            RESULT = lista;
        :}
            
    ;
regCampo ::= TIDENTIFICADOR:id TDOSPTS tipoPrimitivo:tipo {:
            String identificador = id.getLexema();
            TypeIF tipoPrimitivo = scopeManager.searchType(tipo);

            if(!tipo.toUpperCase().equals("BOOLEAN") && !tipo.toUpperCase().equals("INTEGER")) {
                semanticErrorManager.semanticFatalError ("210. El tipo en el registro : " + identificador + "[" + id.getLine() + ":" + id.getColumn() + "] no es bool o int.");
            }

            SymbolIF reg = new SymbolVariable(scopeManager.getCurrentScope(), identificador.toUpperCase(), tipoPrimitivo);

            RESULT = reg;
        :} ntPtoComa
            
        | error
            
    ;

//
// DEFINICIÓN DE VARIABLES
//
vars ::= TVAR {:
            ScopeIF scope = scopeManager.getCurrentScope();

            semanticErrorManager.semanticDebug("Analizando las variables del ambito " + scope.getName());

        :} varsLista 
        | /*Nada*/          
    ;

varsLista ::= var varsLista
            | var        
    ;

var ::= varSeqDeIds:lista TDOSPTS varTipo:tipo {:
            ScopeIF scope = scopeManager.getCurrentScope();
            TypeTableIF tablaTipos = scope.getTypeTable();
            SymbolTableIF tablaSimbolos = scope.getSymbolTable();
        
            if (!tablaTipos.containsType(tipo.toUpperCase())) {
                semanticErrorManager.semanticFatalError("el tipo " + tipo + " no ha sido declarado");
            }

            for(int i = 0; i < lista.size(); i++) {
                Var v = (Var) lista.get(i);

                String name = v.getName();

                // comprobamos que la variable no ha sido declarada anteriormente y la guardamos en la tabla de simbolos
                if (!tablaSimbolos.containsSymbol(name.toUpperCase()) ){		
                    semanticErrorManager.semanticDebug("Anadiendo la variable " + name + " a la tabla de simbolos");
                    
                    if (tipo.toUpperCase() != "INTEGER" && tipo.toUpperCase() != "BOOLEAN") { //es un registro                        
                        TypeRecord type = (TypeRecord) tablaTipos.getType(tipo.toUpperCase());

                        HashMap campos = type.getTablaCampos();

                        Iterator it = campos.entrySet().iterator();
                        while (it.hasNext()) {
                            despl++;

                            Map.Entry pair = (Map.Entry)it.next();
                            // System.out.println(pair.getKey() + " = " + pair.getValue());
                            
                            SymbolIF campo = (SymbolIF) pair.getValue();

                            TypeIF tipoDelCampo = campo.getType();

                            SymbolVariable simboloVar = new SymbolVariable(scope, (name + "." +(String) pair.getKey()).toUpperCase(), tipoDelCampo, despl);
                            tablaSimbolos.addSymbol( (name + "." + (String) pair.getKey()).toUpperCase(), simboloVar); 

                        }

                        SymbolVariable simboloVR = new SymbolVariable(scope, name.toUpperCase(), scopeManager.searchType(tipo.toUpperCase()), despl);
                        tablaSimbolos.addSymbol(name.toUpperCase(), simboloVR);   

                    } else {
                        despl++;

                        SymbolVariable simboloVar = new SymbolVariable(scope, name.toUpperCase(), scopeManager.searchType(tipo.toUpperCase()), despl);
                        tablaSimbolos.addSymbol(name.toUpperCase(), simboloVar);   
                    }                                    	
                } else {
                    semanticErrorManager.semanticFatalError ("210. La variable: " + name + " en [" + v.getLine() + ":" + v.getColumn() + "] ya ha sido definida.");
                }
            }

            RESULT = lista;

        :} ntPtoComa
            
        | error
            
    ;
varTipo ::= tipoPrimitivo:tip {: RESULT = tip; :} 
            | TIDENTIFICADOR:tipo {: RESULT = tipo.getLexema(); :}
        ;

//
// DEFINICIÓN DE SUBPROGRAMAS
//
subs ::= subs TPROCEDURE {:
            ScopeIF scope = scopeManager.getCurrentScope();

            semanticErrorManager.semanticDebug("Analizando los subprogramas del ambito " + scope.getName());

        :} subDecl:subDecl cuerpoModulo:bloque {:
            if((subDecl.getEsFuncion() && !bloque.getTieneDevuelve()) || (!subDecl.getEsFuncion() && bloque.getTieneDevuelve())) {
                semanticErrorManager.semanticFatalError("Esto no es una funcion. O falta el devuelve o no hay indicado el tipo del retorno");
            }

            RESULT = bloque;
        :}
        | //Nada
    ;

subDecl ::= TIDENTIFICADOR:identificador subParams:lista subReturn:tipo {:
                String nombreFuncion = identificador.getLexema();

                if (scopeManager.containsSymbol(nombreFuncion.toUpperCase())) {
				    semanticErrorManager.semanticFatalError("350. La funcion "+identificador.getLexema()+" en la linea: "+identificador.getLine()+" ya ha sido declarada");
                } else {     
                    // Crear FUNCION en ambito
                    ScopeIF scope = scopeManager.getCurrentScope();
                    TypeTableIF tablaTipos = scope.getTypeTable();
                    SymbolTableIF tablaSimbolos = scope.getSymbolTable();

                    // a�adir funcion a TT
                    TypeFunction tipoFuncion = new TypeFunction(scope, nombreFuncion.toUpperCase());
                    tablaTipos.addType(nombreFuncion.toUpperCase(), tipoFuncion);

                    ArrayList parametros = new ArrayList(Utilidades.ordenaParametros(lista));

                    // aniadir funcion a TS
                    SymbolFunction simboloFunc = new SymbolFunction(scope, nombreFuncion.toUpperCase(), tablaTipos.getType(nombreFuncion.toUpperCase()));

                    simboloFunc.setParametros(parametros);

                    semanticErrorManager.semanticDebug("Aniadiendo el subprograma " + nombreFuncion + " a la tabla de simbolos");
                    tablaSimbolos.addSymbol(nombreFuncion.toUpperCase(), simboloFunc);            

                    SubDecl declaracion;

				    scopeManager.openScope(nombreFuncion.toUpperCase()); // NUEVO ambito para ser usado dentro funcion y tabla TS y TT

                    tablaTipos = scopeManager.getCurrentScope().getTypeTable();
				    tablaSimbolos = scopeManager.getCurrentScope().getSymbolTable();

                    if(tipo.equals("noType")) {  // el subprograma es un procedimiento
                        declaracion = new SubDecl(false);
                        tipoFuncion.setTipoRetorno(null);
                    } else {                     // es una funcion
                        declaracion = new SubDecl(true);
                        tipoFuncion.setTipoRetorno(scopeManager.searchType(tipo.toUpperCase()));  
                    }
                    
                    for (int i = 0; i < parametros.size(); i++) {
                        Parametro p = (Parametro) parametros.get(i);
                          
                        p.setReferencia(true); // en el tipo son todos por referencia

                        SymbolVariable simboloVar = new SymbolVariable (scopeManager.getCurrentScope(), p.getNombre().toUpperCase(), p.getTipo());//, despl);
                        // despl++;
                        
                        // Creo lista ordenada de parametros en el PROCEDIMIENTO.
                        tipoFuncion.setTypeParametro(p.getColumna(), p.getTipo()); 

                        // Fijar paso parametros Ref/Valor en Symbolvar
                        simboloVar.setReferencia(p.getReferencia());
                        tablaSimbolos.addSymbol(p.getNombre(), simboloVar);                                  	
                        tipoFuncion.setParametro(simboloVar);
                    }

                    //////////////////
                    //cerramos ambito
                    scopeManager.closeScope();

                    RESULT = declaracion;
                }
            :} ntPtoComa
            
        | error
            
    ;
subParams ::= TPARI TPARD {: 
                RESULT = new Lista(); 
            :}      
            | TPARI subParamsCuerpo:lista {: 
                RESULT = lista; 
            :} TPARD    
            | /*nada*/ {: 
                RESULT = new Lista(); 
            :}                         
        ;

subParamsCuerpo ::= subPar:listaParametros ntPtoComa subParamsCuerpo:lista {: 
                        for (int i = 0; i < listaParametros.size(); i++) {
                            lista.add(listaParametros.get(i));
                        }
                        
                        RESULT = lista;
                    :}
            
                | subPar:listaParametros {:
                    RESULT = listaParametros;
                 :}
            
    ;

subPar ::= TVAR varSeqDeIds:lista TDOSPTS varTipo:tipo {:
            Lista list = (Lista) lista;

            Lista listaParametros = new Lista();

            for (int i = 0; i < list.size(); i++) {
                Var v = (Var) list.get(i);

                String name = v.getName();

                Parametro parametro = new Parametro();

                TypeIF tip = scopeManager.searchType(tipo.toUpperCase());

                parametro.setNombre(name.toUpperCase());
                parametro.setTipo(tip);
                parametro.setColumna(v.getColumn());

                listaParametros.add(parametro);
            }

            RESULT = listaParametros;

        :}
            
        | error
            
    ;
subReturn ::= TDOSPTS:s tipoPrimitivo:tipo {: RESULT = tipo; :}
            | {: RESULT = "noType"; :} //Nada 
            | error
    ;

//
// DEFINICIÓN DE SENTENCIAS
//

    // las sentencias devuelven bloques de sentencias que contienen el código intermedio

sentencias ::= sent:sent ntPtoComa sentencias:blq {:
                    BloqueSentencias bloque = new BloqueSentencias();

                    // si alguno de los bloques 
                    if (blq.getTieneDevuelve() || sent.getTieneDevuelve()) {
                        bloque.setTieneDevuelve(true);
                    }

                    IntermediateCodeBuilderIF cb = new IntermediateCodeBuilder (scopeManager.getCurrentScope());
                    cb.addQuadruples(sent.getIntermediateCode());
                    cb.addQuadruples(blq.getIntermediateCode());
                    List code = cb.create();
                    bloque.setIntermediateCode(code);
				
                	RESULT=bloque;
                :}
                    
                | /*Nada*/ {:
            BloqueSentencias bloque = new BloqueSentencias();
            RESULT = bloque;

:}
                    
                | error
            
    ;
sent ::= sentAsign:sent {: RESULT = sent; :}          //LISTO
        | sentES:sent {: RESULT = sent; :}             //LISTO
        | sentReturn:sent {: RESULT = sent; :}   
        | sentIf:sent {: RESULT = sent; :} TEND       // LISTO?
        | sentWhile:sent {: RESULT = sent; :} TEND    
        | sentCall:sent {: RESULT = sent; :}   
        | error
    ;

sentAsign ::= TIDENTIFICADOR:id TASSIGN expresion:exp {:  //compobamos que está ya declarada, que no es una constante, que si es una función el tipo de retorno es igual al tipo de asignacion
                String identificador = id.getLexema();
                ScopeIF scope = scopeManager.getCurrentScope();

                BloqueSentencias bloque = new BloqueSentencias();

                IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scope); 

                if (!(scopeManager.containsSymbol(identificador.toUpperCase()))) {
                    semanticErrorManager.semanticFatalError ("La variable: " + identificador +" en [" +  id.getLine() + ":" + id.getColumn() + "] no ha sido definida.");
                } else {
                    SymbolIF simbolo = scopeManager.searchSymbol(identificador.toUpperCase());
                    TypeIF tipo = simbolo.getType();

                    // Comprobamos que no es una constante
                    if (simbolo instanceof SymbolConstant) {
                        semanticErrorManager.semanticFatalError ("La constante: " + identificador +" en [" +  id.getLine() + ":" + id.getColumn() + "] no admite asignaciones.");
                    } else {
                        if(!tipo.getName().toUpperCase().equals(exp.getTipo().getName().toUpperCase())){
                            semanticErrorManager.semanticFatalError("Los tipos de la asignación no cuadran");
                        } else {
                            // Creamos codigo para la sentencia 
                            Variable var = new Variable(identificador.toUpperCase(), scope);
                            var.setAmbito(simbolo.getScope());
                            List code1 = exp.getIntermediateCode();
                            cb.addQuadruples(code1);
                            cb.addQuadruple("ASIGNACION", var, exp.getResultado());   

                            bloque.setIntermediateCode(cb.create());
                        }
                    }
                }
                
                RESULT=bloque;
            :}   

            | TIDENTIFICADOR:id TPUNTO TIDENTIFICADOR:campo TASSIGN expresion:exp {: // asignación de registros
                String identificador = id.getLexema().toUpperCase();
                String nombreCampo = campo.getLexema().toUpperCase();

                ScopeIF scope = scopeManager.getCurrentScope();
                IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scope); 
                BloqueSentencias bloque = new BloqueSentencias();

                SymbolTableIF tablaSimbolos = scope.getSymbolTable();

                if (!(scopeManager.containsSymbol(identificador))) {
                    semanticErrorManager.semanticFatalError("La variable de registro: " + identificador +" en [" + id.getLine() + ":" + id.getColumn() + "] no ha sido definida.");
                } else {
                    if (!(scopeManager.containsSymbol(identificador + "." + nombreCampo))) {
                        semanticErrorManager.semanticFatalError("El campo de registro: " + identificador + "." + nombreCampo +" en [" +  id.getLine() + ":" + id.getColumn() + "] no ha sido definida.");
                    }

                    SymbolIF simbolo = scopeManager.searchSymbol(identificador + "." + nombreCampo);
                    TypeIF tipo = simbolo.getType();

                    // Comprobamos que no es una constante
                    if (simbolo instanceof SymbolConstant) {
                        semanticErrorManager.semanticFatalError ("La constante: " + identificador +" en [" +  id.getLine() + ":" + id.getColumn() + "] no admite asignaciones.");
                    } else {
                        if(!tipo.getName().toUpperCase().equals(exp.getTipo().getName().toUpperCase())){ //los tipos son distintos
                            semanticErrorManager.semanticFatalError("Los tipos de la asignación no cuadran");
                        } else {
                            // Creamos codigo para la sentencia 
                            Variable var = new Variable(identificador + "." + nombreCampo, scope);

                            var.setAmbito(simbolo.getScope());
                            List code1 = exp.getIntermediateCode();
                            cb.addQuadruples(code1);
                            cb.addQuadruple("ASIGNACION", var, exp.getResultado());   

                            bloque.setIntermediateCode(cb.create());
                        }
                    }
                }
                
                RESULT=bloque;
            :}
    ;

sentWhile ::= TWHILE:id expresion:exp TDO sentencias:blq {:
                if(!(exp.getTipo().getName().toString().equals("BOOLEAN"))) {
					semanticErrorManager.semanticFatalError("Error en " + id.getLexema() + ": la expresiOn no es de tipo boolean");
                }

                BloqueSentencias bloque = new BloqueSentencias();
				ScopeIF scope = scopeManager.getCurrentScope();
				IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scope);

                LabelFactory lf = new LabelFactory(scope.getName());

				LabelIF LFALSE = lf.create();
				LabelIF LINICIO = lf.create();

                cb.addQuadruple("LABEL", LINICIO);
                cb.addQuadruples(exp.getIntermediateCode());
                cb.addQuadruple("CMP", exp.getResultado(), new Value(1));
				cb.addQuadruple("BNZ", LFALSE);   // Salto no cero
                cb.addQuadruples(blq.getIntermediateCode());
                cb.addQuadruple("BR", LINICIO);
                cb.addQuadruple("LABEL", LFALSE);

                bloque.setIntermediateCode(cb.create());

				RESULT = bloque;
            :}
;

sentIf ::= TIF:id expresion:exp TTHEN sentencias:sent1 sentElse:sent2 {:
            if ( !(exp.getTipo().getName().toUpperCase().equals("BOOLEAN")) ) {
				semanticErrorManager.semanticFatalError("Error en " + id.getLexema() + ": la expresiOn no es de tipo boolean");
            }
                BloqueSentencias bloque = new BloqueSentencias();
				ScopeIF scope = scopeManager.getCurrentScope();
				IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scope);

                LabelFactory lf= new LabelFactory(scope.getName());

				LabelIF LTRUE = lf.create();
				LabelIF LFALSE = lf.create();

                cb.addQuadruples(exp.getIntermediateCode());
                cb.addQuadruple("CMP", exp.getResultado(), new Value(1));
				cb.addQuadruple("BNZ", LFALSE);
				cb.addQuadruples(sent1.getIntermediateCode());
				cb.addQuadruple("BR", LTRUE);
				cb.addQuadruple("LABEL", LFALSE);
				cb.addQuadruples(sent2.getIntermediateCode());
				cb.addQuadruple("LABEL", LTRUE);
                cb.addQuadruple("NOP", null);

                List code = cb.create();
                bloque.setIntermediateCode(code);
                RESULT=bloque;
        :};

sentElse ::= TELSE sentencias:sent {:
            // BloqueSentencias bloque = new BloqueSentencias();
            RESULT = sent;
        :}
            
        | /*Nada */ {:
            BloqueSentencias bloque = new BloqueSentencias();
            RESULT = bloque;

:}
            
    ;
sentES ::= TWRITESTRING:id TPARI TLSTRING:cad TPARD {:
            BloqueSentencias bloqueSentencias = new BloqueSentencias ();
            bloqueSentencias.setTieneDevuelve(false);
            IntermediateCodeBuilder cb = new IntermediateCodeBuilder (scopeManager.getCurrentScope());

            cadenas.add(cad.getLexema());

            cb.addQuadruple("WRSTR","cadena"+cadenas.size());
            bloqueSentencias.setIntermediateCode(cb.create());
            RESULT = bloqueSentencias;
:}

        | TWRITEINT:id TPARI expresion:exp TPARD  {:
            if (exp.getTipo()!=null){
                if (!exp.getTipo().getName().toString().toUpperCase().equals("INTEGER")){
                    semanticErrorManager.semanticFatalError ("Una sentencia escribeEnt [" + id.getLine() + ":" + id.getColumn() + "] solo puede recibir variable o constante de tipo entero.");
                } else {
                    BloqueSentencias bloqueSentencias = new BloqueSentencias ();
                    IntermediateCodeBuilder cb = new IntermediateCodeBuilder (scopeManager.getCurrentScope());
                    cb.addQuadruples(exp.getIntermediateCode());
                                cb.addQuadruple("WRINT", exp.getResultado());
                    bloqueSentencias.setIntermediateCode(cb.create());
                    bloqueSentencias.setTieneDevuelve(false);
                    RESULT = bloqueSentencias;
                }
            }
:}
        | TWRITELN {:
            BloqueSentencias bloqueSentencias = new BloqueSentencias ();
            bloqueSentencias.setTieneDevuelve(false);
            IntermediateCodeBuilder cb = new IntermediateCodeBuilder (scopeManager.getCurrentScope());
            cb.addQuadruple("WRTLN", null);
            bloqueSentencias.setIntermediateCode(cb.create());
            RESULT = bloqueSentencias;
:}                          
    ;

sentReturn ::= TRETURN expresion {:
            BloqueSentencias bloque = new BloqueSentencias();

            bloque.setTieneDevuelve(true);

            RESULT = bloque;
        :}
            
    ;

sentCall ::= TIDENTIFICADOR:id TPARI sentCallParams:lista TPARD {:
            BloqueSentencias bloque = new BloqueSentencias();

            ScopeIF scope = scopeManager.getCurrentScope();
            SymbolTableIF symbolTable = scope.getSymbolTable();
            TypeTableIF typeTable = scope.getTypeTable();

            if(!symbolTable.containsSymbol(id.getLexema().toUpperCase())) {
                semanticErrorManager.semanticFatalError("el simbolo " + id.getLexema() + " no es una funcion");
            }

            SymbolFunction symbolFunction = (SymbolFunction)symbolTable.getSymbol(id.getLexema().toUpperCase());
            
            ArrayList<Parametro> parametros= symbolFunction.getParametros();

            if(symbolFunction instanceof SymbolFunction) {
                for(int i = 0; i < lista.size(); i++) {
                    String var = (String) lista.get(i);

                    if(!symbolTable.containsSymbol(var.toUpperCase())) {
                        semanticErrorManager.semanticFatalError("el simbolo " + id.getLexema() + " no ha sido declarado previamente");
                    }

                    SymbolIF symbol = symbolTable.getSymbol(var);

                    String type = symbol.getType().getName();

                    if(!type.toUpperCase().equals(parametros.get(i).getTipo().getName())) {
                        semanticErrorManager.semanticFatalError("el tipo de " + var + " no coincide con el del parametro");
                    }
                }
            }

            RESULT = bloque;

:}
        | TIDENTIFICADOR {:
            BloqueSentencias bloque = new BloqueSentencias();
            RESULT = bloque;

:}                           
    ;
sentCallParams ::= TIDENTIFICADOR:id {:
            // BloqueSentencias bloque = new BloqueSentencias();

            Lista lista = new Lista();

            lista.add(id.getLexema());

            RESULT = lista;

:}
            
        | TIDENTIFICADOR:id TCOMA sentCallParams:list {:
            // BloqueSentencias bloque = new BloqueSentencias();
            Lista lista = new Lista();

            lista.add(id.getLexema());

            for(int i =0; i < list.size(); i++) {//String id: list) {
                lista.add(list.get(i));
            }

            RESULT = lista;

:}
            
        | TIDENTIFICADOR:id1 TPUNTO TIDENTIFICADOR:id2 {:
            // BloqueSentencias bloque = new BloqueSentencias();
            Lista lista = new Lista();

            lista.add(id1.getLexema() + "." + id2.getLexema());

            RESULT = lista;

:}
            
        | TIDENTIFICADOR:id1 TPUNTO TIDENTIFICADOR:id2 TCOMA sentCallParams:list {:
            // BloqueSentencias bloque = new BloqueSentencias();
            Lista lista = new Lista();

            lista.add(id1.getLexema() + "." + id2.getLexema());
           
            for(int i =0; i < list.size(); i++) {//String id: list) {
                lista.add(list.get(i));
            }

            RESULT = lista;

:}
            
        | /*Nada*/ {:
            // BloqueSentencias bloque = new BloqueSentencias();
            RESULT = new Lista();

:}
            
        | error
            
    ;

expresion::=
        TNOT:id expresion:exp {:
            Expresion expresion = new Expresion (scopeManager.searchType("BOOLEAN"), id.getLine(), id.getColumn());

            if (exp.getTipo()!=null){
                if (!exp.getTipo().getName().toString().toUpperCase().equals("BOOLEAN")){
                    semanticErrorManager.semanticFatalError ("1 Una expresiOn lOgica debe usar tipos LOGICOS con el operador: " + id.getLexema() + " [" + id.getLine() + ":" + id.getColumn() + "].");
                } else {
                    ScopeIF scope = scopeManager.getCurrentScope();
                    TemporalFactoryIF tF = new TemporalFactory(scope);
                    IntermediateCodeBuilderIF cb = new IntermediateCodeBuilder(scope);

                    TemporalIF temp1 = exp.getTemporal();
                    TemporalIF temp = tF.create();

                    cb.addQuadruples(exp.getIntermediateCode());
                    cb.addQuadruple("NOT", temp1, temp);
                    
                    expresion.setResultado(temp);
                    expresion.setIntermediateCode(cb.create());
                }
            }

            RESULT = expresion;
        :}

        | TPARI expresion:expresion TPARD {:    //listo
            RESULT = expresion;
        :}

        | expresion:exp1 TDIVIDE:id expresion:exp2 {:/*aritmeticos*/
            if ( !(exp1.getTipo() == exp2.getTipo()  ||  !(exp1.getTipo().getName().toUpperCase().equals("INTEGER"))  || !(exp2.getTipo().getName().toUpperCase().equals("INTEGER")) ) ) {
                semanticErrorManager.semanticFatalError ("232. La expresion: " + id.getLexema() +" en [" + id.getLine() + ":" + id.getColumn() + "] no es del mismo tipo.");
			} else {
                Expresion exp = new Expresion(scopeManager.searchType("INTEGER"), id.getLine(), id.getColumn());
                if (exp.castingTipos(exp1 , exp2) ) {
                        semanticErrorManager.semanticFatalError ("222. La expresion: " + id.getLexema() +" en [" + id.getLine() + ":" + id.getColumn() + "] no es del mismo tipo.");
                }else{
                    ScopeIF scope = scopeManager.getCurrentScope();

                    TemporalFactoryIF tf = new TemporalFactory(scope); 
                    Temporal temporal = (Temporal) tf.create(); 
                    temporal.setDesplazamiento(despl);
                    despl++;
                    IntermediateCodeBuilderIF cb = new IntermediateCodeBuilder(scope);
                    List code1 = exp1.getIntermediateCode();
                    List code2 = exp2.getIntermediateCode();
                    cb.addQuadruples (code1);
                    cb.addQuadruples (code2);
                
                    cb.addQuadruple ("DIV", temporal, exp1.getResultado(), exp2.getResultado()); // temporal <- exp1 - exp2
                    List code=cb.create ();
                    exp.setResultado (temporal);    
                    exp.setIntermediateCode (code);  
                                            
                    RESULT=exp;
                }
            }
        :}               
        | expresion:exp1 TSUMA:id expresion:exp2 {:
            if ( !(exp1.getTipo() == exp2.getTipo()  ||  !(exp1.getTipo().getName().toUpperCase().equals("INTEGER"))  || !(exp2.getTipo().getName().toUpperCase().equals("INTEGER")) ) ) {
                semanticErrorManager.semanticFatalError ("La expresion: " + id.getLexema() +" en [" + id.getLine() + ":" + id.getColumn() + "] no es del mismo tipo.");
			} else {
                ScopeIF scope = scopeManager.getCurrentScope();
                IntermediateCodeBuilderIF cb = new IntermediateCodeBuilder(scope);
                Expresion exp = new Expresion(scopeManager.searchType("INTEGER"), id.getLine(), id.getColumn());

                TemporalFactoryIF tf = new TemporalFactory(scope); 

                Temporal temporal = (Temporal) tf.create(); 
                
                if (exp.castingTipos(exp1 , exp2) ){
                    semanticErrorManager.semanticFatalError ("La expresion: " + id.getLexema() +" en [" + id.getLine() + ":" + id.getColumn() + "] no es del mismo tipo.");
                }

                temporal.setDesplazamiento(despl);
                despl++;
                List code1 = exp1.getIntermediateCode();
                List code2 = exp2.getIntermediateCode();
                cb.addQuadruples (code1);
                cb.addQuadruples (code2);
                cb.addQuadruple ("ADD", temporal, exp1.getResultado(), exp2.getResultado());

                List code=cb.create ();
                exp.setResultado (temporal); 
                exp.setTipo(scopeManager.searchType("INTEGER"));
                exp.setIntermediateCode (code); 
                RESULT=exp;
            }
        :}                 
        | expresion:exp1 TAND:id expresion:exp2 {:
            if ( !(exp1.getTipo() == exp2.getTipo() || !(exp1.getTipo().getName().toUpperCase().equals("BOOLEAN")) || !(exp2.getTipo().getName().toUpperCase().equals("BOOLEAN")) ) ){
                semanticErrorManager.semanticFatalError ("228. La expresion: " + id.getLexema() +" en [" + id.getLine() + ":" + id.getColumn() + "] no es del mismo tipo.");
            } else {
                if (exp1.getTipo()!=null && exp2.getTipo()!=null){
                    if (!exp1.getTipo().getName().toString().toUpperCase().equals("BOOLEAN") || !exp2.getTipo().getName().toString().toUpperCase().equals("BOOLEAN")){
                      semanticErrorManager.semanticFatalError ("2 Una expresiOn lOgica debe usar tipos enteros con el operador: " + id.getLexema() + " [" + id.getLine() + ":" + id.getColumn() + "].");
                    } else {
                        //MEMORIA: Considero l�gica de cortocircuito. Adem�s <=0 es falso, y el resto verdadero.
                        Expresion exp = new Expresion (scopeManager.searchType("INTEGER"), id.getLine(), id.getColumn());
                        ScopeIF scope = scopeManager.getCurrentScope();
                        TemporalFactory tf = new TemporalFactory (scope);
                        LabelFactory labelFactory= new LabelFactory(scope.getName());

                        // Integer numTemporal=scopeManager.getScope().getTemporalTable().getTemporals().size();
                        // Integer posTemp=numTemporal+despl;
                        TemporalIF t = tf.create();
                        // t.setDesplazamiento(posTemp);
                        LabelIF lTrue = labelFactory.create();
                        LabelIF lFalse = labelFactory.create();
                        IntermediateCodeBuilder cb=new IntermediateCodeBuilder (scope);
                        cb.addQuadruples (exp1.getIntermediateCode());
                        cb.addQuadruples (exp2.getIntermediateCode());
                        //Cortocircuito, if a then b else false
                        Value Verdadero=new Value(1);
                        Value Falso=new Value(0);

                        cb.addQuadruple ("CMP", Verdadero, exp1.getResultado()); //compara
                        cb.addQuadruple ("BN",lTrue); //salto negativo
                        cb.addQuadruple ("ASIGNACION", t, exp2.getResultado());
                        cb.addQuadruple ("BR",lFalse);//salto incondicional
                        cb.addQuadruple ("LABEL",lTrue);
                        cb.addQuadruple ("ASIGNACION", t, Falso);
                        cb.addQuadruple ("LABEL",lFalse);
                        exp.setIntermediateCode(cb.create());
                        exp.setResultado(t);

                        exp.setTipo(scopeManager.searchType("BOOLEAN"));

                        RESULT = exp;                            
                    }
                }
            }
        :}    
        | expresion:exp1 TMENOR:id expresion:exp2 {: /*comparaciones*/
            //comprobamos todo tipos y demas
             if ( !(exp1.getTipo() == exp2.getTipo()  ||  !(exp1.getTipo().getName().toUpperCase().equals("INTEGER"))  || !(exp2.getTipo().getName().toUpperCase().equals("INTEGER")) ) ) {
                semanticErrorManager.semanticFatalError ("232. La expresion: " + id.getLexema() +" en [" + id.getLine() + ":" + id.getColumn() + "] no es del mismo tipo.");
			}
                Expresion exp = new Expresion(scopeManager.searchType("BOOLEAN"), id.getLine(), id.getColumn());
                ScopeIF scope = scopeManager.getCurrentScope();
				//   TemporalFactoryIF tf = CompilerContext.getTemporalFactory(scope);			
                TemporalFactory tf = new TemporalFactory (scope);
	
                Temporal temporal = (Temporal) tf.create(); 
                               despl++;

                temporal.setDesplazamiento(despl);
                IntermediateCodeBuilderIF cb = new IntermediateCodeBuilder(scope);
                List code1 = exp1.getIntermediateCode();
                List code2 = exp2.getIntermediateCode();
                cb.addQuadruples (code1);
                cb.addQuadruples (code2);
                Value verdad = new Value(1);
                Value falso = new Value(0);
                //   LabelFactoryIF lf = CompilerContext.getLabelFactory();	
                LabelFactory lf= new LabelFactory(scope.getName());
				
                LabelIF LTRUE = lf.create();
                LabelIF LFIN = lf.create();				
                // Hacemos cmp al reves para contemplar caso ambos iguales
                cb.addQuadruple ("CMP", exp1.getResultado(), exp2.getResultado()); 
                cb.addQuadruple ("BN", LTRUE); 
                cb.addQuadruple ("ASIGNACION", temporal, falso);
                cb.addQuadruple ("BR", LFIN);
                cb.addQuadruple ("LABEL", LTRUE);
                cb.addQuadruple ("ASIGNACION", temporal, verdad);
                cb.addQuadruple ("LABEL", LFIN);
                                
                List code=cb.create ();
                exp.setResultado (temporal); 
                exp.setIntermediateCode (code); 

                exp.setTipo(scopeManager.searchType("BOOLEAN"));

				RESULT=exp;
               
        :}                
        | expresion:exp1 TDISTINTO:id expresion:exp2 {:
            //comprobamos todo tipos y demas
             if ( !(exp1.getTipo() == exp2.getTipo() ) ) { // ||  !(exp1.getTipo().getName().toUpperCase().equals("INTEGER"))  || !(exp2.getTipo().getName().toUpperCase().equals("INTEGER")) ) ) {
                semanticErrorManager.semanticFatalError ("232. La expresion: " + id.getLexema() +" en [" + id.getLine() + ":" + id.getColumn() + "] no es del mismo tipo.");
			} else {
                if (exp1.getTipo()!=null && exp2.getTipo()!=null){
/*                     if (!exp1.getTipo().getName().toString().toUpperCase().equals("INTEGER") || !exp2.getTipo().getName().toString().toUpperCase().equals("INTEGER")){
                        semanticErrorManager.semanticFatalError ("3 Una expresion logica debe usar tipos enteros con el operador: " + id.getLexema() + " [" + id.getLine() + ":" + id.getColumn() + "].");
                    } else { */
                        
                        if ( !(exp1.getTipo() == exp2.getTipo() ))
                                  semanticErrorManager.semanticFatalError ("238. La expresion: " + id.getLexema() +" en [" + 
							id.getLine() + ":" + id.getColumn() + "] no es del mismo tipo.");
                            if ( (exp1.getTipo() instanceof TypeRecord) || exp1.getTipo() instanceof TypeSet )
                                  semanticErrorManager.semanticFatalError ("La expresion: " + id.getLexema() +" en [" + 
							id.getLine() + ":" + id.getColumn() + "] no permitida para este tipo.");
                     
                            Expresion exp = new Expresion(scopeManager.searchType("BOOLEAN"), id.getLine(), id.getColumn());
                            ScopeIF scope = scopeManager.getCurrentScope();
                            
                            TemporalFactoryIF tf = new TemporalFactory(scope);  //cambiado
                            Temporal temporal = (Temporal) tf.create(); 
                                                        despl++;

                            temporal.setDesplazamiento(despl);
                            
                            IntermediateCodeBuilderIF cb = new IntermediateCodeBuilder(scope);
                            List code1 = exp1.getIntermediateCode();
                            List code2 = exp2.getIntermediateCode();
                            cb.addQuadruples (code1);
                            cb.addQuadruples (code2);
                            Value verdad = new Value(1);
                            Value falso = new Value(0);
                
                            LabelFactory lf = new LabelFactory(scope.getName());
                            LabelIF LTRUE = lf.create();
                            LabelIF LFIN = lf.create();
                            cb.addQuadruple ("CMP", exp1.getResultado(), exp2.getResultado()); 
                            cb.addQuadruple ("BNZ", LTRUE); 
                            cb.addQuadruple ("ASIGNACION", temporal, falso);
                            cb.addQuadruple ("BR", LFIN);
                            cb.addQuadruple ("LABEL", LTRUE);
                            cb.addQuadruple ("ASIGNACION", temporal, verdad);
                            cb.addQuadruple ("LABEL", LFIN);

                            List code=cb.create ();
                            exp.setResultado (temporal); 
                            exp.setIntermediateCode (code); 
                            
                            exp.setTipo(scopeManager.searchType("BOOLEAN")); //esto es mio!!!

                            RESULT=exp;
                    //}
                }
            }
        :}
        | TLINT:num {:   
            ScopeIF scope = scopeManager.getCurrentScope();
            Expresion exp = new Expresion(scopeManager.searchType("INTEGER"), num.getLine(), num.getColumn());
            Value resultado=new Value(Integer.parseInt(num.getLexema()));
            exp.setResultado(resultado);  // Guardamos el valor operador
            RESULT = exp;
        :}                                      /*tipos primitivos*/
        | TLTRUE:trueValue {:       //listo
            ScopeIF scope = scopeManager.getCurrentScope();
            TemporalFactoryIF tf = new TemporalFactory(scope);
            IntermediateCodeBuilderIF cb = new IntermediateCodeBuilder(scope);

            Expresion expresion = new Expresion(scopeManager.searchType("BOOLEAN"), trueValue.getLine(), trueValue.getColumn());
            
            // Le damos el valor true=1 y false=0
            Value resultado = new Value(1);

            TemporalIF temp = tf.create();
            
            cb.addQuadruple("MV", temp, resultado);

            expresion.setTemporal(temp);
            expresion.setTipo(scopeManager.searchType("BOOLEAN"));
            expresion.setResultado(resultado);

            RESULT = expresion;
        :}
        | TLFALSE:falseValue {:     //listo
            ScopeIF scope = scopeManager.getCurrentScope();
            TemporalFactoryIF tf = new TemporalFactory(scope);
            IntermediateCodeBuilderIF cb = new IntermediateCodeBuilder(scope);

            Expresion expresion = new Expresion(scopeManager.searchType("BOOLEAN"), falseValue.getLine(), falseValue.getColumn());
            
            // Le damos el valor true=1 y false=0
            Value resultado = new Value(0);

            TemporalIF temp = tf.create();
            
            cb.addQuadruple("MV", temp, resultado);

            expresion.setTemporal(temp);
            expresion.setTipo(scopeManager.searchType("BOOLEAN"));
            expresion.setResultado(resultado);

            RESULT = expresion;
        :}
        | TIDENTIFICADOR:id {:  //esto debería estar terminado asi
            ScopeIF scope = scopeManager.getCurrentScope();
            SymbolTableIF tablaSimbolos = scope.getSymbolTable();
            TypeTableIF tablaTipos = scope.getTypeTable();
            
            if (!(scopeManager.containsSymbol(id.getLexema().toUpperCase()))) {
                semanticErrorManager.semanticFatalError ("La variable: " + id.getLexema() +" en [" + id.getLine() + ":" + id.getColumn() + "] no ha sido definida.");
            } else {
                SymbolIF simbolo = scopeManager.searchSymbol(id.getLexema().toUpperCase());
                Expresion exp = new Expresion(simbolo.getType(), id.getLine(), id.getColumn());
                
                if (simbolo instanceof SymbolConstant) {
					SymbolConstant simboloCte = (SymbolConstant) simbolo;
					Value valor = new Value(simboloCte.getValue());
                    exp.setResultado(valor);
                } else {
                    Variable var = new Variable(id.getLexema().toUpperCase(), scope);
                    var.setAmbito(simbolo.getScope());
                    exp.setReferencia(true);
                    exp.setResultado(var);
                }
                RESULT = exp;
            }
        :}                             /*variable o constante*/
        | TIDENTIFICADOR:id1 TPUNTO TIDENTIFICADOR:id2  {:
            String registro = id1.getLexema().toUpperCase();
            String campo = id2.getLexema().toUpperCase();

            ScopeIF scope = scopeManager.getCurrentScope();
            TypeTableIF tablaTipos = scope.getTypeTable();

            if ( !(scopeManager.containsSymbol(registro + "." + campo)) ) {
                semanticErrorManager.semanticFatalError("El tipo registro: " + id1.getLexema() +" en [" + id1.getLine() + ":" + id1.getColumn() + "] no ha sido definida.");
            }

            SymbolIF record = scopeManager.searchSymbol(registro);

            System.out.println(record);

            TypeRecord typeRecord = (TypeRecord) scopeManager.searchType(record.getType().getName().toUpperCase());

            if(!typeRecord.containsCampo(campo)) {
                semanticErrorManager.semanticFatalError("El registro " + registro + " no contiene el campo " + campo);
            }

            SymbolIF simbolo = scopeManager.searchSymbol(registro+ "." + campo);
            Expresion exp = new Expresion(simbolo.getType(), id2.getLine(), id2.getColumn());
            
            if (simbolo instanceof SymbolConstant) {
                SymbolConstant simboloCte = (SymbolConstant) simbolo;
                Value valor = new Value(simboloCte.getValue());
                exp.setResultado(valor);
            } else {
                Variable var = new Variable(registro+ "." + campo, scope);
                var.setAmbito(simbolo.getScope());
                exp.setReferencia(true);
                exp.setResultado(var);
            }

            RESULT = exp;
        :}

        | TIDENTIFICADOR TPARI sentCallParams TPARD  /*invocacion*/      {:

        :}                                  
        | error   
    ;

//
// Reglas auxiliares
//
tipoPrimitivo ::= TINTEGER:integer {: RESULT = "INTEGER"; :}     
                | TBOOLEAN:bool {: RESULT = "BOOLEAN"; :}
    ;
varSeqDeIds ::= TIDENTIFICADOR:id {: 
                    String varName = id.getLexema();

                    Var var = new Var();

                    var.setName(varName);
                    var.setColumn(id.getColumn());
                    Lista lista = new Lista();

                    lista.add(var);

                    RESULT = lista;
                :}
                    
                | TIDENTIFICADOR:id TCOMA varSeqDeIds:list {:
                    Lista lista = new Lista();

                    for(int i=0; i < list.size(); i++) {
                        lista.add(list.get(i));
                    }

                    String varName = id.getLexema();

                    Var var = new Var();
                    var.setName(varName);

                    lista.add(var);

                    RESULT = lista;
                :}
    ;

cuerpoModulo ::= ctes tipos vars subs TBEGIN finalModulo:bloque {:
            RESULT = bloque;
        :}

        | error
            
    ;
finalModulo ::= sentencias:bloque TEND TIDENTIFICADOR {:
                    RESULT = bloque;
                :} ntPtoComa 
        | error
            
    ;
ntPtoComa ::= //Varios ';' seguidos deben ser interpretados como uno solo.        
        TPTOCOMA | TPTOCOMA ntPtoComa
    ;
