package compiler.syntax;

// Declaración de importaciones 
//(No modificar las proporcionadas. Se pueden agregar mas)

import java_cup.runtime.Symbol;
import java.util.*;

import es.uned.lsi.compiler.lexical.*;
import es.uned.lsi.compiler.code.*;
import es.uned.lsi.compiler.intermediate.*;
import es.uned.lsi.compiler.semantic.*;
import es.uned.lsi.compiler.semantic.symbol.*;
import es.uned.lsi.compiler.semantic.type.*;
import es.uned.lsi.compiler.syntax.*;

import compiler.CompilerContext;
import compiler.lexical.*;
import compiler.syntax.nonTerminal.*;
import compiler.semantic.*;
import compiler.semantic.symbol.*;
import compiler.semantic.type.*;
import compiler.intermediate.*;
import compiler.code.*;

import compiler.semantic.utils.*;

// Declaración del código de usuario

action code   {:
	
	SyntaxErrorManager   syntaxErrorManager   = CompilerContext.getSyntaxErrorManager();
	SemanticErrorManager semanticErrorManager = CompilerContext.getSemanticErrorManager ();
	ScopeManagerIF       scopeManager         = CompilerContext.getScopeManager ();
	FinalCodeFactoryIF   finalCodeFactory     = CompilerContext.getFinalCodeFactory ();

	// cadenas que aniadir al final  del archivo en ensamblador
	List cadenas = new ArrayList();
	// Desplazamiento para las posiciones a partir de IY
	int despl = 0;
    // posicion de los campos de los registros
    int pos = 0;
:}	

parser code {:
	SyntaxErrorManager syntaxErrorManager = CompilerContext.getSyntaxErrorManager();
	
	public void syntax_error(Symbol symbol)
	{ 
	    Token token = (Token) symbol.value;
	    syntaxErrorManager.syntaxError ("Error sintactico", token);	    
	}
		
	public void unrecovered_syntax_error(java_cup.runtime.Symbol symbol)
	{	
	    Token token = (Token) symbol.value;
	    syntaxErrorManager.syntaxFatalError ("Error fatal", token);
	}
:}


// Declaración de terminales
terminal Token TLTRUE, TLFALSE, TLINT, TLSTRING, TIDENTIFICADOR;
terminal Token TAND, TNOT;
terminal Token TBEGIN, TEND;
terminal Token TIF, TTHEN, TELSE;
terminal Token TMODULE, TPROCEDURE, TRETURN;
terminal Token TDO, TWHILE;
terminal Token TWRITESTRING, TWRITEINT, TWRITELN;
terminal Token TBOOLEAN, TCONST, TINTEGER, TRECORD, TTYPE, TVAR;
terminal Token TPTOCOMA, TPARI, TPARD, TCOMA, TDOSPTS, TIGUAL;
terminal Token TSUMA, TDIVIDE, TASSIGN, TMENOR, TDISTINTO, TPUNTO;

// Declaración de no terminales
non terminal  		    program;
non terminal Axiom		axiom;

non terminal                 ctes;
non terminal            ctesLista;
non terminal                  cte;
non terminal       Token cteValor;
non terminal                tipos;
non terminal           tiposLista;
non terminal      TypeRecord tipo;
non terminal       Lista registro;
non terminal      Lista regCampos;
non terminal    SymbolIF regCampo;
non terminal                 vars;
non terminal            varsLista;
non terminal                  var;
non terminal        String varTipo;
non terminal                 subs;
non terminal             SubDecl subDecl;
non terminal      Lista subParams;
non terminal Lista subParamsCuerpo;
non terminal         Lista subPar;
non terminal     String subReturn;
non terminal        BloqueSentencias   sentencias;
non terminal       BloqueSentencias          sent;
non terminal      BloqueSentencias      sentAsign;
non terminal      BloqueSentencias         sentES;
non terminal    BloqueSentencias       sentReturn;
non terminal    BloqueSentencias         sentCall;
non terminal   Lista    sentCallParams;
non terminal    BloqueSentencias           sentIf;
non terminal       BloqueSentencias      sentElse;
non terminal         BloqueSentencias   sentWhile;
non terminal  Expresion expresion;
non terminal String tipoPrimitivo;
non terminal        BloqueSentencias cuerpoModulo;
non terminal         BloqueSentencias finalModulo;
non terminal    Lista varSeqDeIds;
non terminal            ntPtoComa;

// Declaración de relaciones de precedencia (de menos a más)
precedence nonassoc TMENOR, TDISTINTO;
precedence left     TSUMA;
precedence left     TDIVIDE, TAND;
precedence right    TNOT;
precedence left     TPUNTO, TPARI, TPARD;

// Declaración de reglas de producción
// El proceso de análisis ha de empezar emitiendo el mensaje 'Starting parsing...' y
// finalizar emitiendo el mensaje 'Parsing process finished' en el caso de no existir 
// ningún error no recuperable.

start with program;

program ::= 
  {: syntaxErrorManager.syntaxInfo ("Starting parsing..."); 
	
	
  :}
  axiom:ax
  {: 
  		// No modificar esta estructura, aunque se pueden añadir más acciones semánticas
  		
  		List intermediateCode = ax.getIntermediateCode ();
        finalCodeFactory.setEnvironment(CompilerContext.getExecutionEnvironment());
  		finalCodeFactory.create(intermediateCode);

  		// En caso de no comentarse las dos sentencias anteriores puede generar una excepcion
  		// en las llamadas a cupTest si el compilador no está completo. Esto es debido a que 
  		// aún no se tendrá implementada la generación de código intermedio ni final.
  		// Para la entrega final deberán descomentarse y usarse.
  		
  		syntaxErrorManager.syntaxInfo ("Parsing process ended.");
  :};


axiom ::= TMODULE TIDENTIFICADOR:id ntPtoComa {: 
            String programName = id.getLexema();
            scopeManager.openScope(programName); 
  		
            ScopeIF scope = scopeManager.getCurrentScope();

			TypeTableIF tablaTipos = scope.getTypeTable();

            // aniadimos los tipos simples
            TypeSimple tipoBooleano = new TypeSimple(scope);
            tipoBooleano.setName("BOOLEAN");
			tablaTipos.addType(tipoBooleano);

			TypeSimple tipoEntero = new TypeSimple(scope);
            tipoEntero.setName("INTEGER");
            tablaTipos.addType(tipoEntero);
            
        :} cuerpoModulo:bloque {:
            Axiom ax = new Ax();

            IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scopeManager.getCurrentScope());

            cb.addQuadruples(bloque.getIntermediateCode());            
            cb.addQuadruple("HALT", null);

            int i=1;
            cb.addQuadruple ("STRING", "cadena0","\"\\n\"", "");
            for (Iterator it = cadenas.iterator(); it.hasNext();i++){    //ponemos las cadenas al final de las cuadruplas
                String nombre="cadena"+i;
                cb.addQuadruple("STRING", nombre,it.next(), "");
            }

/*             syntaxErrorManager.syntaxInfo("====> CODIGO INTERMEDIO");

            Iterator it = intermediateCode.iterator();
            while (it.hasNext()){
                syntaxErrorManager.syntaxInfo("** " + it.next().toString());
            } */

            ax.setIntermediateCode(cb.create());

            RESULT = ax;
        :}
        | TMODULE error {:syntaxErrorManager.syntaxFatalError("1. No se ha especificado nombre al programa");:}
            
    ;

//
// DEFINICIÓN DE CONSTANTES
//
ctes ::= TCONST {: 
            ScopeIF scope = scopeManager.getCurrentScope();

            semanticErrorManager.semanticDebug("Analizando las constantes del ambito " + scope.getName());

        :} ctesLista  
        | /*nada*/ ;

ctesLista ::= cte ctesLista | cte;

cte ::= TIDENTIFICADOR:id TIGUAL cteValor:value {: 
            String identificador = id.getLexema();
            String valor = value.getLexema();
            
            int val;

            ScopeIF scope = scopeManager.getCurrentScope();
            SymbolTableIF symbolTable = scope.getSymbolTable();

            if (symbolTable.containsSymbol(identificador)) {
                semanticErrorManager.semanticFatalError("La constante "+ identificador+" en la linea: "+id.getLine()+" ya ha sido declarada");
            }

            String tipo = "BOOLEAN";

            if (valor.toUpperCase().equals("TRUE")) {
                val = 1;
            } else if (valor.toUpperCase().equals("FALSE")) {
                val = 0;
            } else { // integer
                val = Integer.parseInt(valor);
                tipo = "INTEGER";
            }

            SymbolConstant simboloCte = new SymbolConstant(scope, identificador.toUpperCase(), scopeManager.searchType(tipo), despl);
            simboloCte.setValue(val);

            symbolTable.addSymbol(identificador.toUpperCase(), simboloCte);
 
            String typeOfValue = Utilidades.getTypeOfValue(valor);

            if (typeOfValue.equals("noValidType")) {
                semanticErrorManager.semanticFatalError("La constante " + identificador + " en la linea " + id.getLine()+ " no tiene un tipo valido");
            }
        :} ntPtoComa

    | error {: semanticErrorManager.semanticFatalError("Error en la declaracion de constantes"); :}
            
    ;
cteValor ::= TLTRUE:bool {: RESULT=bool; :}      
            | TLFALSE:bool {: RESULT=bool; :} 
            | TLINT:entero {: RESULT=entero; :} 
    ;

//
// DEFINICIÓN DE TIPOS
//
tipos ::= TTYPE {:
            ScopeIF scope = scopeManager.getCurrentScope();

            semanticErrorManager.semanticDebug("Analizando los tipos del ambito " + scope.getName());

        :} tiposLista 
        | /*nada*/
	;

tiposLista ::= tipo tiposLista
        | //nada
	;

tipo ::= TIDENTIFICADOR:id TIGUAL registro:lista {: //aqui registramos el tipo
            String identificador = id.getLexema();

            ScopeIF scope = scopeManager.getCurrentScope();
			TypeTableIF tablaTipos = scope.getTypeTable();

            if (scopeManager.containsType(identificador.toUpperCase())) {
                semanticErrorManager.semanticFatalError("El tipo: " + identificador + " en " + id.getLine() + ":" + id.getColumn() + " ya ha sido definida.");
            }

            TypeRecord tipoRegistro = new TypeRecord(scope, identificador.toUpperCase());

            for(int i = 0; i < lista.size(); i++) {
                SymbolIF campo = (SymbolIF) lista.get(i);

                tipoRegistro.getTablaCampos().put(campo.getName().toUpperCase(), campo);
            }

            tipoRegistro.setSize(pos);

            tablaTipos.addType(tipoRegistro);
            
            pos = 0;

        :} ntPtoComa
        | error
            
    ;

registro ::= TRECORD regCampos:lista {: 
            RESULT = lista; 
        :} TEND
            
        | error
            
    ;
regCampos ::= regCampo:reg regCampos:lista {:
                lista.add(reg);
                RESULT = lista;
            :}
            
        | regCampo:reg {:
            Lista lista = new Lista();
            lista.add(reg);
            RESULT = lista;
        :}
            
    ;
regCampo ::= TIDENTIFICADOR:id TDOSPTS tipoPrimitivo:tipo {:
            String identificador = id.getLexema();
            TypeIF tipoPrimitivo = scopeManager.searchType(tipo);

            if(!tipo.toUpperCase().equals("BOOLEAN") && !tipo.toUpperCase().equals("INTEGER")) {
                semanticErrorManager.semanticFatalError ("El tipo en el registro : " + identificador + " en " + id.getLine() + ":" + id.getColumn() + " no es BOOLEAN o INT.");
            }

            SymbolIF reg = new SymbolVariable(scopeManager.getCurrentScope(), identificador.toUpperCase(), tipoPrimitivo, pos);
            pos++;

            RESULT = reg;
        :} ntPtoComa
            
        | error {: semanticErrorManager.semanticFatalError("El campo de registro no esta bien formado"); :}
            
    ;

//
// DEFINICIÓN DE VARIABLES
//
vars ::= TVAR {:
            ScopeIF scope = scopeManager.getCurrentScope();

            semanticErrorManager.semanticDebug("Analizando las variables del ambito " + scope.getName());

        :} varsLista 
        | /*Nada*/          
    ;

varsLista ::= var varsLista
            | var        
    ;

var ::= varSeqDeIds:lista TDOSPTS varTipo:tipo {:
            ScopeIF scope = scopeManager.getCurrentScope();
            TypeTableIF tablaTipos = scope.getTypeTable();
            SymbolTableIF tablaSimbolos = scope.getSymbolTable();
        
            if (!tablaTipos.containsType(tipo.toUpperCase())) {
                semanticErrorManager.semanticFatalError("el tipo " + tipo + " no ha sido declarado");
            }

            for(int i = 0; i < lista.size(); i++) {
                Var v = (Var) lista.get(i);

                String name = v.getName();

                // comprobamos que la variable no ha sido declarada anteriormente y la guardamos en la tabla de simbolos
                if (!tablaSimbolos.containsSymbol(name.toUpperCase()) ){
                    TypeIF type = scopeManager.searchType(tipo.toUpperCase());
                        SymbolVariable simboloVR = new SymbolVariable(scope, name.toUpperCase(), type, despl);
                         
                        if(type instanceof TypeRecord) {
                            despl = despl + scopeManager.searchType(tipo.toUpperCase()).getSize();
                        }

                        despl++;

                        tablaSimbolos.addSymbol(name.toUpperCase(), simboloVR);                                   	
                } else {
                    semanticErrorManager.semanticFatalError("La variable: " + name + " en " + v.getLine() + ":" + v.getColumn() + " ya ha sido definida.");
                }
            }

            RESULT = lista;

        :} ntPtoComa
            
        | error {: semanticErrorManager.semanticFatalError("La variables no estan bien formadas"); :}
            
    ;
varTipo ::= tipoPrimitivo:tip {: RESULT = tip; :} 
            | TIDENTIFICADOR:tipo {: RESULT = tipo.getLexema(); :}
        ;

//
// DEFINICIÓN DE SUBPROGRAMAS
//
subs ::= subs TPROCEDURE:id subDecl:subDecl cuerpoModulo:bloque {:
            if((subDecl.getEsFuncion() && !bloque.getTieneDevuelve()) || (!subDecl.getEsFuncion() && bloque.getTieneDevuelve())) {
                semanticErrorManager.semanticFatalError(id.getLine() + ": Esto no es una funcion. O falta el devuelve o no hay indicado el tipo del retorno");
            }

            RESULT = bloque;
        :}
        | //Nada
    ;

subDecl ::= TIDENTIFICADOR:identificador subParams:lista subReturn:tipo {:
                String nombreFuncion = identificador.getLexema();

                if (scopeManager.containsSymbol(nombreFuncion.toUpperCase())) {
				    semanticErrorManager.semanticFatalError("350. La funcion "+identificador.getLexema()+" en la linea: "+identificador.getLine()+" ya ha sido declarada");
                } else {     
                    ScopeIF scope = scopeManager.getCurrentScope();
                    TypeTableIF tablaTipos = scope.getTypeTable();
                    SymbolTableIF tablaSimbolos = scope.getSymbolTable();

                    TypeFunction tipoFuncion = new TypeFunction(scope, nombreFuncion.toUpperCase());
                    tablaTipos.addType(nombreFuncion.toUpperCase(), tipoFuncion);

                    ArrayList parametros = new ArrayList(Utilidades.ordenaParametros(lista));

                    SymbolFunction simboloFunc = new SymbolFunction(scope, nombreFuncion.toUpperCase(), tablaTipos.getType(nombreFuncion.toUpperCase()));

                    simboloFunc.setParametros(parametros);

                    semanticErrorManager.semanticDebug("Aniadiendo el subprograma " + nombreFuncion + " a la tabla de simbolos");
                    tablaSimbolos.addSymbol(nombreFuncion.toUpperCase(), simboloFunc);            

                    SubDecl declaracion;

				    scopeManager.openScope(nombreFuncion.toUpperCase()); // NUEVO ambito para ser usado dentro funcion y tabla TS y TT

                    tablaTipos = scopeManager.getCurrentScope().getTypeTable();
				    tablaSimbolos = scopeManager.getCurrentScope().getSymbolTable();

                    if(tipo.equals("noType")) {  // el subprograma es un procedimiento
                        declaracion = new SubDecl(false);
                        tipoFuncion.setTipoRetorno(null);
                    } else {                     // es una funcion
                        declaracion = new SubDecl(true);
                        tipoFuncion.setTipoRetorno(scopeManager.searchType(tipo.toUpperCase()));  
                    }
                    
                    for (int i = 0; i < parametros.size(); i++) {
                        Parametro p = (Parametro) parametros.get(i);
                          
                        p.setReferencia(true); // en el tipo son todos por referencia

                        SymbolVariable simboloVar = new SymbolVariable (scopeManager.getCurrentScope(), p.getNombre().toUpperCase(), p.getTipo());//, despl);
                        // despl++;
                        
                        // Creo lista ordenada de parametros en el PROCEDIMIENTO.
                        tipoFuncion.setTypeParametro(p.getColumna(), p.getTipo()); 

                        // Fijar paso parametros Ref/Valor en Symbolvar
                        simboloVar.setReferencia(p.getReferencia());
                        tablaSimbolos.addSymbol(p.getNombre(), simboloVar);                                  	
                        tipoFuncion.setParametro(simboloVar);
                    }

                    scopeManager.closeScope();

                    RESULT = declaracion;
                }
            :} ntPtoComa
            
        | error {: semanticErrorManager.semanticFatalError("Error en la declaracion de subprogramas"); :}
            
    ;
subParams ::= TPARI TPARD {: 
                RESULT = new Lista(); 
            :}      
            | TPARI subParamsCuerpo:lista {: 
                RESULT = lista; 
            :} TPARD    
            | /*nada*/ {: 
                RESULT = new Lista(); 
            :}                         
        ;

subParamsCuerpo ::= subPar:listaParametros ntPtoComa subParamsCuerpo:lista {: 
                        for (int i = 0; i < listaParametros.size(); i++) {
                            lista.add(listaParametros.get(i));
                        }
                        
                        RESULT = lista;
                    :}
            
                | subPar:listaParametros {:
                    RESULT = listaParametros;
                 :}
            
    ;

subPar ::= TVAR varSeqDeIds:lista TDOSPTS varTipo:tipo {:
            Lista list = (Lista) lista;

            Lista listaParametros = new Lista();

            for (int i = 0; i < list.size(); i++) {
                Var v = (Var) list.get(i);

                String name = v.getName();

                Parametro parametro = new Parametro();

                TypeIF tip = scopeManager.searchType(tipo.toUpperCase());

                parametro.setNombre(name.toUpperCase());
                parametro.setTipo(tip);
                parametro.setColumna(v.getColumn());

                listaParametros.add(parametro);
            }

            RESULT = listaParametros;

        :}
            
        | error {: semanticErrorManager.semanticFatalError("Los parametros no estan bien formados"); :}
            
    ;
subReturn ::= TDOSPTS:s tipoPrimitivo:tipo {: RESULT = tipo; :}
            | {: RESULT = "noType"; :} //Nada 
            | error {: semanticErrorManager.semanticFatalError("No esta bien formado el tipo de retorno de la funcion"); :}
    ;

//
// DEFINICIÓN DE SENTENCIAS
//

    // las sentencias devuelven bloques de sentencias que contienen el código intermedio

sentencias ::= sent:sent ntPtoComa sentencias:blq {:
                    BloqueSentencias bloque = new BloqueSentencias();

                    if (blq.getTieneDevuelve() || sent.getTieneDevuelve()) {
                        bloque.setTieneDevuelve(true);
                    }

                    IntermediateCodeBuilderIF cb = new IntermediateCodeBuilder (scopeManager.getCurrentScope());
                    cb.addQuadruples(sent.getIntermediateCode());
                    cb.addQuadruples(blq.getIntermediateCode());

                    bloque.setIntermediateCode(cb.create());
				
                	RESULT=bloque;
                :}
                    
                | /*Nada*/ {:
                    RESULT = new BloqueSentencias();
                :}
                    
                | error {: semanticErrorManager.semanticFatalError("Error en la formacion de sentencias"); :}
            
    ;
sent ::= sentAsign:sent {: RESULT = sent; :}
        | sentES:sent {: RESULT = sent; :}
        | sentReturn:sent {: RESULT = sent; :}   
        | sentIf:sent {: RESULT = sent; :} TEND
        | sentWhile:sent {: RESULT = sent; :} TEND    
        | sentCall:sent {: RESULT = sent; :}   
        | error {: semanticErrorManager.semanticFatalError("Sentencia no permitida"); :}
    ;

sentAsign ::= TIDENTIFICADOR:id TASSIGN expresion:exp {:  //compobamos que está ya declarada, que no es una constante, que si es una función el tipo de retorno es igual al tipo de asignacion
                String identificador = id.getLexema();
                ScopeIF scope = scopeManager.getCurrentScope();

                BloqueSentencias bloque = new BloqueSentencias();

                IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scope); 

                if (!(scopeManager.containsSymbol(identificador.toUpperCase()))) {
                    semanticErrorManager.semanticFatalError ("La variable: " + identificador +" en [" +  id.getLine() + ":" + id.getColumn() + "] no ha sido definida.");
                } else {
                    SymbolIF simbolo = scopeManager.searchSymbol(identificador.toUpperCase());
                    TypeIF tipo = simbolo.getType();

                    if (simbolo instanceof SymbolConstant) { // Comprobamos que no es una constante
                        semanticErrorManager.semanticFatalError ("La constante: " + identificador +" en [" +  id.getLine() + ":" + id.getColumn() + "] no admite asignaciones.");
                    } else {
                        if(!tipo.getName().toUpperCase().equals(exp.getTipo().getName().toUpperCase())){
                            semanticErrorManager.semanticFatalError("Los tipos de la asignación no cuadran");
                        } else {
                            Variable var = new Variable(identificador.toUpperCase(), scope);
                            var.setAmbito(simbolo.getScope());

                            cb.addQuadruples(exp.getIntermediateCode());
                            cb.addQuadruple("ASIGNACION", var, exp.getResultado());   

                            bloque.setIntermediateCode(cb.create());
                        }
                    }
                }
                
                RESULT=bloque;
            :}   

            | TIDENTIFICADOR:id TPUNTO TIDENTIFICADOR:campo TASSIGN expresion:exp {: // asignación de registros
                String identificador = id.getLexema().toUpperCase();
                String nombreCampo = campo.getLexema().toUpperCase();

                if ( !(scopeManager.containsSymbol(identificador)) ) {
                    semanticErrorManager.semanticFatalError ("La variable: " + identificador +" en [" + id.getLine() + ":" + id.getColumn() + "] no ha sido definida.");
                } else {
                    SymbolIF simbolo = scopeManager.searchSymbol(identificador);
                    TypeIF tipo = scopeManager.searchType(simbolo.getType().getName().toUpperCase());

                    if ( !(tipo instanceof TypeRecord) ) {
                        semanticErrorManager.semanticFatalError ("La variable: " + identificador +" en [" + id.getLine() + ":" + id.getColumn() + "] no es un tipo RECORD.");
                    }

                    TypeRecord tipoRec = (TypeRecord) scopeManager.searchType(simbolo.getType().getName().toUpperCase());
                    
                    if ( tipoRec.getTypeCampo(nombreCampo) == null ) {
                        semanticErrorManager.semanticFatalError ("El campo del REG: " + nombreCampo +" en [" + campo.getLine() + ":" + campo.getColumn() + "] no ha sido definido.");
                    }

                    if ( !(tipoRec.getTypeCampo(nombreCampo).getName().toUpperCase().equals(exp.getTipo().getName().toUpperCase())) ){ 
                            semanticErrorManager.semanticFatalError ("La Asignacion: " + identificador +" en [" + id.getLine() + ":" + id.getColumn() + "] no coincide en tipos.");
                    }
                
                    ScopeIF scope = scopeManager.getCurrentScope();
                    IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scope);
                    BloqueSentencias bloque = new BloqueSentencias();
                    Variable var = new Variable(identificador, scope);
                    var.setAmbito(simbolo.getScope());

                    HashMap tablaCampos = tipoRec.getTablaCampos();
                    SymbolVariable simboloCampo = (SymbolVariable) tablaCampos.get(nombreCampo); 
                    Variable var2 = new Variable(nombreCampo, scope);
                    var2.setDesplCampo(simboloCampo.getDesplazamiento());
        
                    cb.addQuadruples(exp.getIntermediateCode());
                    cb.addQuadruple("ASIG_REGISTRO", var, var2, exp.getResultado());

                    bloque.setIntermediateCode(cb.create());                
                    
                    RESULT=bloque;
                }
            :}
    ;

sentWhile ::= TWHILE:id expresion:exp TDO sentencias:blq {:
                if(!(exp.getTipo().getName().toString().equals("BOOLEAN"))) {
					semanticErrorManager.semanticFatalError("Error en " + id.getLexema() + ": la expresiOn no es de tipo boolean");
                }

                BloqueSentencias bloque = new BloqueSentencias();
				ScopeIF scope = scopeManager.getCurrentScope();
				IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scope);

                LabelFactory lf = new LabelFactory(scope.getName());

				LabelIF LFalse = lf.create();
				LabelIF LINICIO = lf.create();

                cb.addQuadruple("LABEL", LINICIO);
                cb.addQuadruples(exp.getIntermediateCode());
                cb.addQuadruple("CMP", exp.getResultado(), new Value(1));
				cb.addQuadruple("BNZ", LFalse);   // Salto no cero
                cb.addQuadruples(blq.getIntermediateCode());
                cb.addQuadruple("BR", LINICIO);
                cb.addQuadruple("LABEL", LFalse);

                bloque.setIntermediateCode(cb.create());

				RESULT = bloque;
            :}
;

sentIf ::= TIF:id expresion:exp TTHEN sentencias:sent1 sentElse:sent2 {:
            if ( !(exp.getTipo().getName().toUpperCase().equals("BOOLEAN")) ) {
				semanticErrorManager.semanticFatalError("Error en " + id.getLexema() + ": la expresiOn no es de tipo boolean");
            }
                BloqueSentencias bloque = new BloqueSentencias();
				ScopeIF scope = scopeManager.getCurrentScope();
				IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scope);

                LabelFactory lf= new LabelFactory(scope.getName());

				LabelIF LTrue = lf.create();
				LabelIF LFalse = lf.create();

                if(!sent2.vacio) {
                    cb.addQuadruples(exp.getIntermediateCode());
                    cb.addQuadruple("CMP", exp.getResultado(), new Value(1));
                    cb.addQuadruple("BNZ", LFalse);
                    cb.addQuadruples(sent1.getIntermediateCode());
                    cb.addQuadruple("BR", LTrue);
                    cb.addQuadruple("LABEL", LFalse);
                    cb.addQuadruples(sent2.getIntermediateCode());
                    cb.addQuadruple("LABEL", LTrue);
                    cb.addQuadruple("NOP", null);
                } else { /* es un if solo */
                    cb.addQuadruples(exp.getIntermediateCode());
                    cb.addQuadruple("CMP", exp.getResultado(), new Value(1));
                    cb.addQuadruple("BNZ",LFalse);   // Salto negativo
                    cb.addQuadruples(sent1.getIntermediateCode());
                    cb.addQuadruple("LABEL", LFalse);
                    cb.addQuadruple ("NOP", null);
                }

                bloque.setIntermediateCode(cb.create());

                RESULT=bloque;
        :};

sentElse ::= TELSE sentencias:sent {: RESULT = sent; :}
            
        | /*Nada */ {: RESULT = new BloqueSentencias(true); :}
            
    ;
sentES ::= TWRITESTRING:id TPARI TLSTRING:cad TPARD {:
            BloqueSentencias bloqueSentencias = new BloqueSentencias ();
            bloqueSentencias.setTieneDevuelve(false);
            IntermediateCodeBuilder cb = new IntermediateCodeBuilder (scopeManager.getCurrentScope());

            cadenas.add(cad.getLexema());

            cb.addQuadruple("WRSTR","cadena"+cadenas.size());
            cb.addQuadruple("WRTLN", null);

            bloqueSentencias.setIntermediateCode(cb.create());
            RESULT = bloqueSentencias;
:}

        | TWRITEINT:id TPARI expresion:exp TPARD  {:
            if (exp.getTipo()!=null){
                if (!exp.getTipo().getName().toString().toUpperCase().equals("INTEGER")){
                    semanticErrorManager.semanticFatalError ("Una sentencia escribeEnt [" + id.getLine() + ":" + id.getColumn() + "] solo puede recibir variable o constante de tipo entero.");
                } else {
                    BloqueSentencias bloqueSentencias = new BloqueSentencias ();
                    IntermediateCodeBuilder cb = new IntermediateCodeBuilder (scopeManager.getCurrentScope());
                    cb.addQuadruples(exp.getIntermediateCode());
                    cb.addQuadruple("WRINT", exp.getResultado());
                                cb.addQuadruple("WRTLN", null);

                    bloqueSentencias.setIntermediateCode(cb.create());
                    bloqueSentencias.setTieneDevuelve(false);
                    RESULT = bloqueSentencias;
                }
            }
:}
        | TWRITELN {:
            BloqueSentencias bloqueSentencias = new BloqueSentencias ();
            bloqueSentencias.setTieneDevuelve(false);
            IntermediateCodeBuilder cb = new IntermediateCodeBuilder (scopeManager.getCurrentScope());
            cb.addQuadruple("WRTLN", null);
            bloqueSentencias.setIntermediateCode(cb.create());
            RESULT = bloqueSentencias;
:}                          
    ;

sentReturn ::= TRETURN expresion {:
            BloqueSentencias bloque = new BloqueSentencias();

            bloque.setTieneDevuelve(true);

            RESULT = bloque;
        :}
            
    ;

sentCall ::= TIDENTIFICADOR:id TPARI sentCallParams:lista TPARD {:
            BloqueSentencias bloque = new BloqueSentencias();

            ScopeIF scope = scopeManager.getCurrentScope();
            SymbolTableIF symbolTable = scope.getSymbolTable();
            TypeTableIF typeTable = scope.getTypeTable();

            if(!symbolTable.containsSymbol(id.getLexema().toUpperCase())) {
                semanticErrorManager.semanticFatalError("el simbolo " + id.getLexema() + " no es una funcion");
            }

            SymbolFunction symbolFunction = (SymbolFunction)symbolTable.getSymbol(id.getLexema().toUpperCase());
            
            ArrayList<Parametro> parametros= symbolFunction.getParametros();

            if(symbolFunction instanceof SymbolFunction) {
                for(int i = 0; i < lista.size(); i++) {
                    String var = (String) lista.get(i);

                    if(!symbolTable.containsSymbol(var.toUpperCase())) {
                        semanticErrorManager.semanticFatalError("el simbolo " + id.getLexema() + " no ha sido declarado previamente");
                    }

                    SymbolIF symbol = symbolTable.getSymbol(var);

                    String type = symbol.getType().getName();

                    if(!type.toUpperCase().equals(parametros.get(i).getTipo().getName())) {
                        semanticErrorManager.semanticFatalError("el tipo de " + var + " no coincide con el del parametro");
                    }
                }
            }

            RESULT = bloque;

:}
        | TIDENTIFICADOR {:
            BloqueSentencias bloque = new BloqueSentencias();
            RESULT = bloque;

:}                           
    ;
sentCallParams ::= TIDENTIFICADOR:id {:
            Lista lista = new Lista();

            lista.add(id.getLexema());

            RESULT = lista;
        :}
            
        | TIDENTIFICADOR:id TCOMA sentCallParams:list {:
            Lista lista = new Lista();

            lista.add(id.getLexema());

            for(int i =0; i < list.size(); i++) {
                lista.add(list.get(i));
            }

            RESULT = lista;
        :}
            
        | TIDENTIFICADOR:id1 TPUNTO TIDENTIFICADOR:id2 {:
            Lista lista = new Lista();

            lista.add(id1.getLexema() + "." + id2.getLexema());

            RESULT = lista;
        :}
            
        | TIDENTIFICADOR:id1 TPUNTO TIDENTIFICADOR:id2 TCOMA sentCallParams:list {:
            Lista lista = new Lista();

            lista.add(id1.getLexema() + "." + id2.getLexema());
           
            for(int i =0; i < list.size(); i++) {
                lista.add(list.get(i));
            }

            RESULT = lista;
        :}
            
        | /*Nada*/ {:
            RESULT = new Lista();
        :}
            
        | error
            
    ;

expresion::=
        TNOT:id expresion:exp {:
            Expresion expresion = new Expresion (scopeManager.searchType("BOOLEAN"), id.getLine(), id.getColumn());

            if (exp.getTipo()!=null){
                if (!exp.getTipo().getName().toString().toUpperCase().equals("BOOLEAN")){
                    semanticErrorManager.semanticFatalError ("Una expresiOn logica debe usar tipos LOGICOS con el operador: " + id.getLexema() + " [" + id.getLine() + ":" + id.getColumn() + "].");
                } else {
                    ScopeIF scope = scopeManager.getCurrentScope();
                    TemporalFactory tf = new TemporalFactory (scope);

                    Temporal t = (Temporal) tf.create();
                    t.setDesplazamiento(despl);
                    despl++;
                    
                    LabelFactory lf= new LabelFactory(scope.getName());

                    LabelIF lTrue = lf.create();
                    LabelIF lFalse = lf.create();

                    IntermediateCodeBuilder cb=new IntermediateCodeBuilder (scope);
                    cb.addQuadruples(exp.getIntermediateCode());
                    
                    Value Verdadero=new Value(1);
                    Value Falso=new Value(0);

                    cb.addQuadruple ("CMP", Verdadero, exp.getResultado()); //compara
                    cb.addQuadruple ("BNZ",lTrue); //salto negativo
                    cb.addQuadruple ("ASIGNACION", t, Falso);
                    cb.addQuadruple ("BR",lFalse);//salto incondicional
                    cb.addQuadruple ("LABEL",lTrue);
                    cb.addQuadruple ("ASIGNACION", t, Verdadero);
                    cb.addQuadruple ("LABEL",lFalse);

                    expresion.setIntermediateCode(cb.create());
                    expresion.setResultado(t);

                    RESULT = expresion;
                }
            }

        :}

        | TPARI expresion:expresion TPARD {: RESULT = expresion; :}

        | expresion:exp1 TDIVIDE:id expresion:exp2 {:/*aritmeticos*/
            if ( !(exp1.getTipo() == exp2.getTipo()  ||  !(exp1.getTipo().getName().toUpperCase().equals("INTEGER"))  || !(exp2.getTipo().getName().toUpperCase().equals("INTEGER")) ) ) {
                semanticErrorManager.semanticFatalError ("232. La expresion: " + id.getLexema() +" en [" + id.getLine() + ":" + id.getColumn() + "] no es del mismo tipo.");
			} else {
                Expresion exp = new Expresion(scopeManager.searchType("INTEGER"), id.getLine(), id.getColumn());
                if (exp.castingTipos(exp1 , exp2) ) {
                        semanticErrorManager.semanticFatalError ("222. La expresion: " + id.getLexema() +" en [" + id.getLine() + ":" + id.getColumn() + "] no es del mismo tipo.");
                }else{
                    ScopeIF scope = scopeManager.getCurrentScope();

                    TemporalFactoryIF tf = new TemporalFactory(scope); 
                    Temporal temporal = (Temporal) tf.create(); 
                    temporal.setDesplazamiento(despl);
                    despl++;

                    IntermediateCodeBuilderIF cb = new IntermediateCodeBuilder(scope);
                    cb.addQuadruples(exp1.getIntermediateCode());
                    cb.addQuadruples(exp2.getIntermediateCode());
                
                    cb.addQuadruple("DIV", temporal, exp1.getResultado(), exp2.getResultado());

                    exp.setResultado(temporal);    
                    exp.setIntermediateCode(cb.create());  
                                            
                    RESULT=exp;
                }
            }
        :}               
        | expresion:exp1 TSUMA:id expresion:exp2 {:
            if ( !(exp1.getTipo() == exp2.getTipo()  ||  !(exp1.getTipo().getName().toUpperCase().equals("INTEGER"))  || !(exp2.getTipo().getName().toUpperCase().equals("INTEGER")) ) ) {
                semanticErrorManager.semanticFatalError ("La expresion: " + id.getLexema() +" en [" + id.getLine() + ":" + id.getColumn() + "] no es del mismo tipo.");
			} else {
                ScopeIF scope = scopeManager.getCurrentScope();
                IntermediateCodeBuilderIF cb = new IntermediateCodeBuilder(scope);
                Expresion exp = new Expresion(scopeManager.searchType("INTEGER"), id.getLine(), id.getColumn());

                TemporalFactoryIF tf = new TemporalFactory(scope); 

                Temporal temporal = (Temporal) tf.create(); 
                
                if (exp.castingTipos(exp1 , exp2) ){
                    semanticErrorManager.semanticFatalError ("La expresion: " + id.getLexema() +" en [" + id.getLine() + ":" + id.getColumn() + "] no es del mismo tipo.");
                }

                temporal.setDesplazamiento(despl);
                despl++;

                cb.addQuadruples(exp1.getIntermediateCode());
                cb.addQuadruples(exp2.getIntermediateCode());
                cb.addQuadruple("ADD", temporal, exp1.getResultado(), exp2.getResultado());

                exp.setResultado(temporal); 
                exp.setTipo(scopeManager.searchType("INTEGER"));
                exp.setIntermediateCode(cb.create ()); 

                RESULT=exp;
            }
        :}                 
        | expresion:exp1 TAND:id expresion:exp2 {:
            if ( !(exp1.getTipo() == exp2.getTipo() || !(exp1.getTipo().getName().toUpperCase().equals("BOOLEAN")) || !(exp2.getTipo().getName().toUpperCase().equals("BOOLEAN")) ) ){
                semanticErrorManager.semanticFatalError ("La expresion: " + id.getLexema() +" en [" + id.getLine() + ":" + id.getColumn() + "] no es del mismo tipo.");
            } else {
                if (exp1.getTipo()!=null && exp2.getTipo()!=null){
                    if (!exp1.getTipo().getName().toString().toUpperCase().equals("BOOLEAN") || !exp2.getTipo().getName().toString().toUpperCase().equals("BOOLEAN")){
                      semanticErrorManager.semanticFatalError ("Una expresiOn lOgica debe usar tipos enteros con el operador: " + id.getLexema() + " [" + id.getLine() + ":" + id.getColumn() + "].");
                    } else {
                        Expresion exp = new Expresion (scopeManager.searchType("INTEGER"), id.getLine(), id.getColumn());
                        ScopeIF scope = scopeManager.getCurrentScope();
                        TemporalFactory tf = new TemporalFactory (scope);
                        LabelFactory labelFactory= new LabelFactory(scope.getName());
                        IntermediateCodeBuilder cb=new IntermediateCodeBuilder (scope);

                        Temporal temporal = (Temporal) tf.create();
                        temporal.setDesplazamiento(despl);
                        despl++;

                        LabelIF lTrue = labelFactory.create();
                        LabelIF lFalse = labelFactory.create();

                        Value Verdadero=new Value(1);
                        Value Falso=new Value(0);

                        cb.addQuadruples(exp1.getIntermediateCode());
                        cb.addQuadruples(exp2.getIntermediateCode());

                        cb.addQuadruple("CMP", Verdadero, exp1.getResultado());
                        cb.addQuadruple("BNZ",lTrue); //salto negativo
                        cb.addQuadruple("ASIGNACION", temporal, exp2.getResultado());
                        cb.addQuadruple("BR",lFalse);//salto incondicional
                        cb.addQuadruple("LABEL",lTrue);
                        cb.addQuadruple("ASIGNACION", temporal, Falso);
                        cb.addQuadruple("LABEL",lFalse);
                        
                        exp.setResultado(temporal);
                        exp.setIntermediateCode(cb.create());

                        exp.setTipo(scopeManager.searchType("BOOLEAN"));

                        RESULT = exp;                            
                    }
                }
            }
        :}    
        | expresion:exp1 TMENOR:id expresion:exp2 {: /*comparaciones*/
            if ( !(exp1.getTipo() == exp2.getTipo())  ||  !(exp1.getTipo().getName().equals("INTEGER"))  || !(exp2.getTipo().getName().equals("INTEGER")) )  {
                semanticErrorManager.semanticFatalError ("232. La expresion: " + id.getLexema() +" en [" + id.getLine() + ":" + id.getColumn() + "] no es del mismo tipo.");
			} else{
                Expresion exp = new Expresion(scopeManager.searchType("BOOLEAN"), id.getLine(), id.getColumn());
                ScopeIF scope = scopeManager.getCurrentScope();
                
                TemporalFactory tf = new TemporalFactory(scope);
                Temporal temporal = (Temporal) tf.create(); 
                temporal.setDesplazamiento(despl);
                despl++;

                IntermediateCodeBuilderIF cb = new IntermediateCodeBuilder(scope);

                cb.addQuadruples(exp1.getIntermediateCode());
                cb.addQuadruples(exp2.getIntermediateCode());

                Value verdadero = new Value(1);
                Value falso = new Value(0);

                LabelFactory lf= new LabelFactory(scope.getName());
                LabelIF LTrue = lf.create();
                LabelIF LFIN = lf.create();				

                cb.addQuadruple("CMP", exp1.getResultado(), exp2.getResultado()); 
                cb.addQuadruple("BN", LTrue); 
                cb.addQuadruple("ASIGNACION", temporal, falso);
                cb.addQuadruple("BR", LFIN);
                cb.addQuadruple("LABEL", LTrue);
                cb.addQuadruple("ASIGNACION", temporal, verdadero);
                cb.addQuadruple("LABEL", LFIN);
                                
                exp.setResultado(temporal); 
                exp.setIntermediateCode(cb.create ()); 
                    
                RESULT=exp;
            }
               
        :}                
        | expresion:exp1 TDISTINTO:id expresion:exp2 {:
            //comprobamos todo tipos y demas
             if ( !(exp1.getTipo() == exp2.getTipo() ) ) { // ||  !(exp1.getTipo().getName().toUpperCase().equals("INTEGER"))  || !(exp2.getTipo().getName().toUpperCase().equals("INTEGER")) ) ) {
                semanticErrorManager.semanticFatalError ("La expresion: " + id.getLexema() +" en [" + id.getLine() + ":" + id.getColumn() + "] no es del mismo tipo.");
			} else {
                if (exp1.getTipo()!=null && exp2.getTipo()!=null){
/*                     if (!exp1.getTipo().getName().toString().toUpperCase().equals("INTEGER") || !exp2.getTipo().getName().toString().toUpperCase().equals("INTEGER")){
                        semanticErrorManager.semanticFatalError ("Una expresion logica debe usar tipos enteros con el operador: " + id.getLexema() + " [" + id.getLine() + ":" + id.getColumn() + "].");
                    } else { */
                        
                    if ( !(exp1.getTipo() == exp2.getTipo() )){
                        semanticErrorManager.semanticFatalError ("La expresion: " + id.getLexema() +" en [" + id.getLine() + ":" + id.getColumn() + "] no es del mismo tipo.");
                    }  
                    if ( (exp1.getTipo() instanceof TypeRecord)) {
                        semanticErrorManager.semanticFatalError ("La expresion: " + id.getLexema() +" en [" + id.getLine() + ":" + id.getColumn() + "] no permitida para este tipo.");
                    }

                    Expresion exp = new Expresion(scopeManager.searchType("BOOLEAN"), id.getLine(), id.getColumn());
                    ScopeIF scope = scopeManager.getCurrentScope();
                    
                    TemporalFactoryIF tf = new TemporalFactory(scope);  //cambiado
                    Temporal temporal = (Temporal) tf.create(); 
                    temporal.setDesplazamiento(despl);
                    despl++;
                    
                    IntermediateCodeBuilderIF cb = new IntermediateCodeBuilder(scope);

                    cb.addQuadruples(exp1.getIntermediateCode());
                    cb.addQuadruples(exp2.getIntermediateCode());

                    Value verdad = new Value(1);
                    Value falso = new Value(0);
        
                    LabelFactory lf = new LabelFactory(scope.getName());
                    LabelIF LTrue = lf.create();
                    LabelIF LFIN = lf.create();

                    cb.addQuadruple("CMP", exp1.getResultado(), exp2.getResultado()); 
                    cb.addQuadruple("BNZ", LTrue); 
                    cb.addQuadruple("ASIGNACION", temporal, falso);
                    cb.addQuadruple("BR", LFIN);
                    cb.addQuadruple("LABEL", LTrue);
                    cb.addQuadruple("ASIGNACION", temporal, verdad);
                    cb.addQuadruple("LABEL", LFIN);

                    exp.setResultado(temporal); 
                    exp.setIntermediateCode(cb.create()); 
                    
                    exp.setTipo(scopeManager.searchType("BOOLEAN")); //esto es mio!!!

                    RESULT=exp;
                    //}
                }
            }
        :}
        | TLINT:num {:   
            ScopeIF scope = scopeManager.getCurrentScope();
            Expresion exp = new Expresion(scopeManager.searchType("INTEGER"), num.getLine(), num.getColumn());
            Value resultado=new Value(Integer.parseInt(num.getLexema()));
            
            exp.setResultado(resultado);

            RESULT = exp;
        :}                                      /*tipos primitivos*/
        | TLTRUE:trueValue {:       //listo
            ScopeIF scope = scopeManager.getCurrentScope();
            TemporalFactoryIF tf = new TemporalFactory(scope);
            IntermediateCodeBuilderIF cb = new IntermediateCodeBuilder(scope);

            Expresion expresion = new Expresion(scopeManager.searchType("BOOLEAN"), trueValue.getLine(), trueValue.getColumn());
            
            Value resultado = new Value(1);

            TemporalIF temp = tf.create();
            
            cb.addQuadruple("MV", temp, resultado);

            expresion.setTemporal(temp);
            expresion.setTipo(scopeManager.searchType("BOOLEAN"));
            expresion.setResultado(resultado);

            RESULT = expresion;
        :}
        | TLFALSE:falseValue {:     //listo
            ScopeIF scope = scopeManager.getCurrentScope();
            TemporalFactoryIF tf = new TemporalFactory(scope);
            IntermediateCodeBuilderIF cb = new IntermediateCodeBuilder(scope);

            Expresion expresion = new Expresion(scopeManager.searchType("BOOLEAN"), falseValue.getLine(), falseValue.getColumn());
            
            Value resultado = new Value(0);

            TemporalIF temp = tf.create();
            
            cb.addQuadruple("MV", temp, resultado);

            expresion.setTemporal(temp);
            expresion.setTipo(scopeManager.searchType("BOOLEAN"));
            expresion.setResultado(resultado);

            RESULT = expresion;
        :}
        | TIDENTIFICADOR:id {:  //esto debería estar terminado asi
            ScopeIF scope = scopeManager.getCurrentScope();
            SymbolTableIF tablaSimbolos = scope.getSymbolTable();
            TypeTableIF tablaTipos = scope.getTypeTable();
            
            if (!(scopeManager.containsSymbol(id.getLexema().toUpperCase()))) {
                semanticErrorManager.semanticFatalError ("La variable: " + id.getLexema() +" en [" + id.getLine() + ":" + id.getColumn() + "] no ha sido definida.");
            } else {
                SymbolIF simbolo = scopeManager.searchSymbol(id.getLexema().toUpperCase());
                Expresion exp = new Expresion(simbolo.getType(), id.getLine(), id.getColumn());
                
                if (simbolo instanceof SymbolConstant) {
					SymbolConstant simboloCte = (SymbolConstant) simbolo;
					Value valor = new Value(simboloCte.getValue());
                    exp.setResultado(valor);
                } else {
                    Variable var = new Variable(id.getLexema().toUpperCase(), scope);
                    var.setAmbito(simbolo.getScope());
                    exp.setReferencia(true);
                    exp.setResultado(var);
                }

                RESULT = exp;
            }
        :}                             /*variable o constante*/
        | TIDENTIFICADOR:id1 TPUNTO TIDENTIFICADOR:id2  {:
            String registro = id1.getLexema().toUpperCase();
            String campo = id2.getLexema().toUpperCase();

            if ( !(scopeManager.containsSymbol(registro)) ) {
                semanticErrorManager.semanticFatalError("El tipo registro: " + id1.getLexema() +" en [" + id1.getLine() + ":" + id1.getColumn() + "] no ha sido definida.");
            }

            ScopeIF scope = scopeManager.getCurrentScope();
            TypeTableIF tablaTipos = scope.getTypeTable();
            IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scope);
            TemporalFactoryIF tf = new TemporalFactory(scope);

            SymbolIF record = scopeManager.searchSymbol(registro);

            TypeRecord typeRecord = (TypeRecord) scopeManager.searchType(record.getType().getName().toUpperCase());
                            
            Expresion exp = new Expresion(typeRecord.getTypeCampo(campo), id2.getLine(), id2.getColumn());
            HashMap tablaCampos = typeRecord.getTablaCampos();
            SymbolVariable simboloCampo = (SymbolVariable) tablaCampos.get(campo); 

            if(!typeRecord.containsCampo(campo)) { //el campo existe en el registro
                semanticErrorManager.semanticFatalError("El registro " + registro + " no contiene el campo " + campo);
            }

            Variable var = new Variable(registro, scope);
            var.setAmbito(record.getScope());
            Variable var2 = new Variable(campo, scope);
            var2.setDesplCampo(simboloCampo.getDesplazamiento());

            Temporal temporal = (Temporal) tf.create();
            temporal.setDesplazamiento(despl);
            despl++;

            cb.addQuadruple ("ACCESO_REGISTRO", temporal, var , var2); 

            exp.setIntermediateCode(cb.create ()); 
            exp.setResultado(temporal);

            RESULT = exp;
        :}

        | TIDENTIFICADOR TPARI sentCallParams:lista TPARD  /*invocacion*/      {:

        :}                                  
        | error   
    ;

//
// Reglas auxiliares
//
tipoPrimitivo ::= TINTEGER:integer {: RESULT = "INTEGER"; :}     
                | TBOOLEAN:bool {: RESULT = "BOOLEAN"; :}
    ;
varSeqDeIds ::= TIDENTIFICADOR:id {: 
                    String varName = id.getLexema();

                    Var var = new Var();

                    var.setName(varName);
                    var.setColumn(id.getColumn());
                    Lista lista = new Lista();

                    lista.add(var);

                    RESULT = lista;
                :}
                    
                | TIDENTIFICADOR:id TCOMA varSeqDeIds:list {:
                    Lista lista = new Lista();

                    for(int i=0; i < list.size(); i++) {
                        lista.add(list.get(i));
                    }

                    String varName = id.getLexema();

                    Var var = new Var();
                    var.setName(varName);

                    lista.add(var);

                    RESULT = lista;
                :}
    ;

cuerpoModulo ::= ctes tipos vars subs TBEGIN finalModulo:bloque {:
            RESULT = bloque;
        :}

        | error
            
    ;
finalModulo ::= sentencias:bloque TEND TIDENTIFICADOR {:
                    RESULT = bloque;
                :} ntPtoComa 
        | error
            
    ;
ntPtoComa ::= //Varios ';' seguidos deben ser interpretados como uno solo.        
        TPTOCOMA | TPTOCOMA ntPtoComa
    ;
