
//----------------------------------------------------
// The following code was generated by CUP v0.11a beta 20060608
// Mon Jun 10 01:58:45 CEST 2019
//----------------------------------------------------

package compiler.syntax;

import java_cup.runtime.Symbol;
import java.util.*;
import es.uned.lsi.compiler.lexical.*;
import es.uned.lsi.compiler.code.*;
import es.uned.lsi.compiler.intermediate.*;
import es.uned.lsi.compiler.semantic.*;
import es.uned.lsi.compiler.semantic.symbol.*;
import es.uned.lsi.compiler.semantic.type.*;
import es.uned.lsi.compiler.syntax.*;
import compiler.CompilerContext;
import compiler.lexical.*;
import compiler.syntax.nonTerminal.*;
import compiler.semantic.*;
import compiler.semantic.symbol.*;
import compiler.semantic.type.*;
import compiler.intermediate.*;
import compiler.code.*;
import compiler.semantic.utils.*;

/** CUP v0.11a beta 20060608 generated parser.
  * @version Mon Jun 10 01:58:45 CEST 2019
  */
public class parser extends java_cup.runtime.lr_parser {

  /** Default constructor. */
  public parser() {super();}

  /** Constructor which sets the default scanner. */
  public parser(java_cup.runtime.Scanner s) {super(s);}

  /** Constructor which sets the default scanner. */
  public parser(java_cup.runtime.Scanner s, java_cup.runtime.SymbolFactory sf) {super(s,sf);}

  /** Production table. */
  protected static final short _production_table[][] = 
    unpackFromStrings(new String[] {
    "\000\163\000\002\002\004\000\002\050\002\000\002\002" +
    "\004\000\002\051\002\000\002\003\007\000\002\003\004" +
    "\000\002\052\002\000\002\004\005\000\002\004\002\000" +
    "\002\005\004\000\002\005\003\000\002\053\002\000\002" +
    "\006\007\000\002\006\003\000\002\007\003\000\002\007" +
    "\003\000\002\007\003\000\002\054\002\000\002\010\005" +
    "\000\002\010\002\000\002\011\004\000\002\011\002\000" +
    "\002\055\002\000\002\012\007\000\002\012\003\000\002" +
    "\056\002\000\002\013\006\000\002\013\003\000\002\014" +
    "\004\000\002\014\003\000\002\057\002\000\002\015\007" +
    "\000\002\015\003\000\002\060\002\000\002\016\005\000" +
    "\002\016\002\000\002\017\004\000\002\017\003\000\002" +
    "\061\002\000\002\020\007\000\002\020\003\000\002\021" +
    "\003\000\002\021\003\000\002\062\002\000\002\022\007" +
    "\000\002\022\002\000\002\063\002\000\002\023\007\000" +
    "\002\023\003\000\002\024\004\000\002\064\002\000\002" +
    "\024\006\000\002\024\002\000\002\025\005\000\002\025" +
    "\003\000\002\026\006\000\002\026\003\000\002\027\004" +
    "\000\002\027\002\000\002\027\003\000\002\030\005\000" +
    "\002\030\002\000\002\030\003\000\002\031\003\000\002" +
    "\031\003\000\002\031\003\000\002\065\002\000\002\031" +
    "\005\000\002\066\002\000\002\031\005\000\002\031\003" +
    "\000\002\031\003\000\002\032\005\000\002\032\007\000" +
    "\002\041\006\000\002\037\007\000\002\040\004\000\002" +
    "\040\002\000\002\033\006\000\002\033\006\000\002\033" +
    "\003\000\002\034\004\000\002\035\006\000\002\035\003" +
    "\000\002\036\003\000\002\036\005\000\002\036\005\000" +
    "\002\036\007\000\002\036\002\000\002\036\003\000\002" +
    "\042\004\000\002\042\005\000\002\042\005\000\002\042" +
    "\005\000\002\042\005\000\002\042\005\000\002\042\005" +
    "\000\002\042\003\000\002\042\003\000\002\042\003\000" +
    "\002\042\003\000\002\042\005\000\002\042\006\000\002" +
    "\042\003\000\002\043\003\000\002\043\003\000\002\046" +
    "\003\000\002\046\005\000\002\044\010\000\002\044\003" +
    "\000\002\067\002\000\002\045\007\000\002\045\003\000" +
    "\002\047\003\000\002\047\004" });

  /** Access to production table. */
  public short[][] production_table() {return _production_table;}

  /** Parse-action table. */
  protected static final short[][] _action_table = 
    unpackFromStrings(new String[] {
    "\000\273\000\004\020\000\001\002\000\004\002\275\001" +
    "\002\000\004\020\007\001\002\000\004\002\uffff\001\002" +
    "\000\006\003\010\010\011\001\002\000\004\002\ufffc\001" +
    "\002\000\004\036\012\001\002\000\044\002\uff90\003\uff90" +
    "\010\uff90\013\uff90\014\uff90\015\uff90\017\uff90\021\uff90\022" +
    "\uff90\024\uff90\025\uff90\026\uff90\027\uff90\031\uff90\034\uff90" +
    "\035\uff90\036\012\001\002\000\016\003\ufffe\013\ufffe\021" +
    "\ufffe\031\ufffe\034\ufffe\035\ufffe\001\002\000\016\003\015" +
    "\013\ufff9\021\ufff9\031\016\034\ufff9\035\ufff9\001\002\000" +
    "\010\002\uff94\013\uff94\021\uff94\001\002\000\006\003\ufffb" +
    "\010\ufffb\001\002\000\012\013\uffee\021\uffee\034\022\035" +
    "\uffee\001\002\000\004\002\ufffd\001\002\000\010\013\uffde" +
    "\021\uffde\035\054\001\002\000\014\003\ufff0\010\ufff0\013" +
    "\ufff0\021\ufff0\035\ufff0\001\002\000\014\003\024\010\026" +
    "\013\uffec\021\uffec\035\uffec\001\002\000\014\003\uffe9\010" +
    "\uffe9\013\uffe9\021\uffe9\035\uffe9\001\002\000\014\003\024" +
    "\010\026\013\uffec\021\uffec\035\uffec\001\002\000\004\043" +
    "\030\001\002\000\010\013\uffef\021\uffef\035\uffef\001\002" +
    "\000\006\003\032\033\033\001\002\000\004\036\uffeb\001" +
    "\002\000\004\036\uffe6\001\002\000\006\003\035\010\037" +
    "\001\002\000\004\014\uffe8\001\002\000\010\003\uffe1\010" +
    "\uffe1\014\uffe1\001\002\000\010\003\035\010\037\014\uffe4" +
    "\001\002\000\004\042\040\001\002\000\006\030\043\032" +
    "\041\001\002\000\006\036\uff99\040\uff99\001\002\000\004" +
    "\036\uffe3\001\002\000\006\036\uff98\040\uff98\001\002\000" +
    "\004\036\012\001\002\000\010\003\uffe2\010\uffe2\014\uffe2" +
    "\001\002\000\004\014\uffe5\001\002\000\004\014\050\001" +
    "\002\000\004\036\uffe7\001\002\000\004\036\012\001\002" +
    "\000\014\003\uffea\010\uffea\013\uffea\021\uffea\035\uffea\001" +
    "\002\000\010\013\uffed\021\uffed\035\uffed\001\002\000\006" +
    "\003\uffe0\010\uffe0\001\002\000\006\013\uffd4\021\uffd4\001" +
    "\002\000\006\013\057\021\060\001\002\000\024\003\133" +
    "\010\127\014\uffc4\015\134\022\125\024\135\025\132\026" +
    "\124\027\123\001\002\000\006\003\uffd6\010\uffd6\001\002" +
    "\000\006\003\062\010\064\001\002\000\016\003\uffd1\013" +
    "\uffd1\021\uffd1\031\uffd1\034\uffd1\035\uffd1\001\002\000\016" +
    "\003\015\013\ufff9\021\ufff9\031\016\034\ufff9\035\ufff9\001" +
    "\002\000\012\003\uffcd\036\uffcd\037\065\042\uffcd\001\002" +
    "\000\010\003\077\035\076\040\075\001\002\000\010\003" +
    "\070\036\uffc7\042\071\001\002\000\004\036\uffd3\001\002" +
    "\000\004\036\uffc6\001\002\000\006\030\043\032\041\001" +
    "\002\000\004\036\uffc8\001\002\000\004\036\012\001\002" +
    "\000\016\003\uffd2\013\uffd2\021\uffd2\031\uffd2\034\uffd2\035" +
    "\uffd2\001\002\000\010\003\uffd0\036\uffd0\042\uffd0\001\002" +
    "\000\004\010\107\001\002\000\006\036\uffc9\040\uffc9\001" +
    "\002\000\004\040\uffcf\001\002\000\006\036\012\040\uffcb" +
    "\001\002\000\006\003\077\035\076\001\002\000\004\040" +
    "\uffcc\001\002\000\004\040\105\001\002\000\010\003\uffce" +
    "\036\uffce\042\uffce\001\002\000\004\042\112\001\002\000" +
    "\006\041\110\042\uff97\001\002\000\004\010\107\001\002" +
    "\000\004\042\uff96\001\002\000\010\010\115\030\043\032" +
    "\041\001\002\000\006\036\uffca\040\uffca\001\002\000\006" +
    "\036\uffd8\040\uffd8\001\002\000\006\036\uffd7\040\uffd7\001" +
    "\002\000\006\013\uffd5\021\uffd5\001\002\000\004\014\uffbd" +
    "\001\002\000\004\036\uffbb\001\002\000\004\036\uffc0\001" +
    "\002\000\004\014\uffbf\001\002\000\004\036\uffb1\001\002" +
    "\000\004\037\236\001\002\000\020\003\146\004\147\005" +
    "\145\006\144\010\152\012\150\037\151\001\002\000\004" +
    "\036\uffc1\001\002\000\012\036\uffae\037\225\046\224\051" +
    "\226\001\002\000\004\036\uffc2\001\002\000\004\036\012" +
    "\001\002\000\004\037\217\001\002\000\014\002\uff91\013" +
    "\uff91\014\uffc3\021\uff91\036\uffba\001\002\000\020\003\146" +
    "\004\147\005\145\006\144\010\152\012\150\037\151\001" +
    "\002\000\020\003\146\004\147\005\145\006\144\010\152" +
    "\012\150\037\151\001\002\000\004\014\140\001\002\000" +
    "\010\002\uff95\013\uff95\021\uff95\001\002\000\004\010\141" +
    "\001\002\000\004\036\uff93\001\002\000\004\036\012\001" +
    "\002\000\010\002\uff92\013\uff92\021\uff92\001\002\000\024" +
    "\011\uffa0\016\uffa0\023\uffa0\036\uffa0\040\uffa0\044\uffa0\045" +
    "\uffa0\047\uffa0\050\uffa0\001\002\000\024\011\uff9e\016\uff9e" +
    "\023\uff9e\036\uff9e\040\uff9e\044\uff9e\045\uff9e\047\uff9e\050" +
    "\uff9e\001\002\000\024\011\uff9a\016\uff9a\023\uff9a\036\uff9a" +
    "\040\uff9a\044\uff9a\045\uff9a\047\uff9a\050\uff9a\001\002\000" +
    "\024\011\uff9f\016\uff9f\023\uff9f\036\uff9f\040\uff9f\044\uff9f" +
    "\045\uff9f\047\uff9f\050\uff9f\001\002\000\020\003\146\004" +
    "\147\005\145\006\144\010\152\012\150\037\151\001\002" +
    "\000\020\003\146\004\147\005\145\006\144\010\152\012" +
    "\150\037\151\001\002\000\030\011\uff9d\016\uff9d\023\uff9d" +
    "\036\uff9d\037\171\040\uff9d\044\uff9d\045\uff9d\047\uff9d\050" +
    "\uff9d\051\172\001\002\000\016\011\160\023\161\044\157" +
    "\045\156\047\154\050\155\001\002\000\020\003\146\004" +
    "\147\005\145\006\144\010\152\012\150\037\151\001\002" +
    "\000\020\003\146\004\147\005\145\006\144\010\152\012" +
    "\150\037\151\001\002\000\020\003\146\004\147\005\145" +
    "\006\144\010\152\012\150\037\151\001\002\000\020\003" +
    "\146\004\147\005\145\006\144\010\152\012\150\037\151" +
    "\001\002\000\020\003\146\004\147\005\145\006\144\010" +
    "\152\012\150\037\151\001\002\000\024\003\162\010\127" +
    "\014\uffc4\015\134\022\125\024\135\025\132\026\124\027" +
    "\123\001\002\000\010\014\uffc3\017\uffc3\036\uffba\001\002" +
    "\000\004\014\uffb7\001\002\000\024\011\uffa3\016\uffa3\023" +
    "\uffa3\036\uffa3\040\uffa3\044\uffa3\045\uffa3\047\uffa3\050\uffa3" +
    "\001\002\000\024\011\160\016\uffa4\023\uffa4\036\uffa4\040" +
    "\uffa4\044\uffa4\045\156\047\uffa4\050\uffa4\001\002\000\024" +
    "\011\uffa5\016\uffa5\023\uffa5\036\uffa5\040\uffa5\044\uffa5\045" +
    "\uffa5\047\uffa5\050\uffa5\001\002\000\020\011\160\016\uffa1" +
    "\023\uffa1\036\uffa1\040\uffa1\044\157\045\156\001\002\000" +
    "\020\011\160\016\uffa2\023\uffa2\036\uffa2\040\uffa2\044\157" +
    "\045\156\001\002\000\010\003\174\010\175\040\uffa9\001" +
    "\002\000\004\010\173\001\002\000\024\011\uff9c\016\uff9c" +
    "\023\uff9c\036\uff9c\040\uff9c\044\uff9c\045\uff9c\047\uff9c\050" +
    "\uff9c\001\002\000\004\040\uffa8\001\002\000\010\040\uffad" +
    "\041\201\051\200\001\002\000\004\040\177\001\002\000" +
    "\024\011\uff9b\016\uff9b\023\uff9b\036\uff9b\040\uff9b\044\uff9b" +
    "\045\uff9b\047\uff9b\050\uff9b\001\002\000\004\010\203\001" +
    "\002\000\010\003\174\010\175\040\uffa9\001\002\000\004" +
    "\040\uffac\001\002\000\006\040\uffab\041\204\001\002\000" +
    "\010\003\174\010\175\040\uffa9\001\002\000\004\040\uffaa" +
    "\001\002\000\016\011\160\040\207\044\157\045\156\047" +
    "\154\050\155\001\002\000\024\011\uffa6\016\uffa6\023\uffa6" +
    "\036\uffa6\040\uffa6\044\uffa6\045\uffa6\047\uffa6\050\uffa6\001" +
    "\002\000\024\011\uffa7\016\uffa7\023\uffa7\036\uffa7\040\uffa7" +
    "\044\uffa7\045\uffa7\047\uffa7\050\uffa7\001\002\000\016\011" +
    "\160\016\212\044\157\045\156\047\154\050\155\001\002" +
    "\000\026\003\162\010\127\014\uffc4\015\134\017\uffc4\022" +
    "\125\024\135\025\132\026\124\027\123\001\002\000\006" +
    "\014\uffb4\017\215\001\002\000\004\014\uffb6\001\002\000" +
    "\024\003\162\010\127\014\uffc4\015\134\022\125\024\135" +
    "\025\132\026\124\027\123\001\002\000\004\014\uffb5\001" +
    "\002\000\004\007\220\001\002\000\004\040\221\001\002" +
    "\000\004\036\uffb3\001\002\000\026\003\162\010\127\014" +
    "\uffc4\015\134\017\uffc4\022\125\024\135\025\132\026\124" +
    "\027\123\001\002\000\006\014\uffc5\017\uffc5\001\002\000" +
    "\020\003\146\004\147\005\145\006\144\010\152\012\150" +
    "\037\151\001\002\000\010\003\174\010\175\040\uffa9\001" +
    "\002\000\004\010\227\001\002\000\004\046\230\001\002" +
    "\000\020\003\146\004\147\005\145\006\144\010\152\012" +
    "\150\037\151\001\002\000\016\011\160\036\uffb8\044\157" +
    "\045\156\047\154\050\155\001\002\000\004\040\233\001" +
    "\002\000\004\036\uffaf\001\002\000\016\011\160\036\uffb9" +
    "\044\157\045\156\047\154\050\155\001\002\000\016\011" +
    "\160\036\uffb0\044\157\045\156\047\154\050\155\001\002" +
    "\000\020\003\146\004\147\005\145\006\144\010\152\012" +
    "\150\037\151\001\002\000\016\011\160\040\240\044\157" +
    "\045\156\047\154\050\155\001\002\000\004\036\uffb2\001" +
    "\002\000\004\014\242\001\002\000\004\036\uffbe\001\002" +
    "\000\004\014\244\001\002\000\004\036\uffbc\001\002\000" +
    "\006\003\247\010\107\001\002\000\012\003\247\010\107" +
    "\013\uffdc\021\uffdc\001\002\000\012\003\uffd9\010\uffd9\013" +
    "\uffd9\021\uffd9\001\002\000\004\042\252\001\002\000\006" +
    "\013\uffdf\021\uffdf\001\002\000\010\010\115\030\043\032" +
    "\041\001\002\000\004\036\uffdb\001\002\000\004\036\012" +
    "\001\002\000\012\003\uffda\010\uffda\013\uffda\021\uffda\001" +
    "\002\000\006\013\uffdd\021\uffdd\001\002\000\006\003\260" +
    "\010\261\001\002\000\016\003\ufff4\010\ufff4\013\ufff4\021" +
    "\ufff4\034\ufff4\035\ufff4\001\002\000\004\043\265\001\002" +
    "\000\016\003\260\010\261\013\ufff7\021\ufff7\034\ufff7\035" +
    "\ufff7\001\002\000\012\013\ufffa\021\ufffa\034\ufffa\035\ufffa" +
    "\001\002\000\012\013\ufff8\021\ufff8\034\ufff8\035\ufff8\001" +
    "\002\000\010\004\271\005\267\006\266\001\002\000\004" +
    "\036\ufff1\001\002\000\004\036\ufff2\001\002\000\004\036" +
    "\ufff6\001\002\000\004\036\ufff3\001\002\000\004\036\012" +
    "\001\002\000\016\003\ufff5\010\ufff5\013\ufff5\021\ufff5\034" +
    "\ufff5\035\ufff5\001\002\000\042\002\uff8f\003\uff8f\010\uff8f" +
    "\013\uff8f\014\uff8f\015\uff8f\017\uff8f\021\uff8f\022\uff8f\024" +
    "\uff8f\025\uff8f\026\uff8f\027\uff8f\031\uff8f\034\uff8f\035\uff8f" +
    "\001\002\000\004\002\001\001\002" });

  /** Access to parse-action table. */
  public short[][] action_table() {return _action_table;}

  /** <code>reduce_goto</code> table. */
  protected static final short[][] _reduce_table = 
    unpackFromStrings(new String[] {
    "\000\273\000\006\002\003\050\004\001\001\000\002\001" +
    "\001\000\004\003\005\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\004\047\012\001\001\000" +
    "\004\047\273\001\001\000\004\051\013\001\001\000\006" +
    "\004\016\044\017\001\001\000\002\001\001\000\004\052" +
    "\256\001\001\000\004\010\020\001\001\000\002\001\001" +
    "\000\004\016\054\001\001\000\004\054\022\001\001\000" +
    "\006\011\026\012\024\001\001\000\002\001\001\000\006" +
    "\011\052\012\024\001\001\000\002\001\001\000\002\001" +
    "\001\000\004\013\030\001\001\000\004\055\050\001\001" +
    "\000\002\001\001\000\006\014\033\015\035\001\001\000" +
    "\004\056\046\001\001\000\002\001\001\000\006\014\045" +
    "\015\035\001\001\000\002\001\001\000\004\043\041\001" +
    "\001\000\002\001\001\000\004\057\043\001\001\000\002" +
    "\001\001\000\004\047\044\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\004" +
    "\047\051\001\001\000\002\001\001\000\002\001\001\000" +
    "\004\060\244\001\001\000\004\022\055\001\001\000\002" +
    "\001\001\000\024\030\135\031\130\032\127\033\125\034" +
    "\120\035\117\037\121\041\116\045\136\001\001\000\004" +
    "\062\060\001\001\000\004\023\062\001\001\000\002\001" +
    "\001\000\006\004\016\044\115\001\001\000\004\024\065" +
    "\001\001\000\006\025\077\026\100\001\001\000\004\027" +
    "\066\001\001\000\004\063\072\001\001\000\002\001\001" +
    "\000\004\043\071\001\001\000\002\001\001\000\004\047" +
    "\073\001\001\000\002\001\001\000\002\001\001\000\004" +
    "\046\105\001\001\000\002\001\001\000\004\064\103\001" +
    "\001\000\004\047\101\001\001\000\006\025\102\026\100" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\004\046\110" +
    "\001\001\000\002\001\001\000\006\021\112\043\113\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\004\066\242\001\001\000\002\001" +
    "\001\000\002\001\001\000\004\065\240\001\001\000\002" +
    "\001\001\000\002\001\001\000\004\042\234\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\004" +
    "\047\221\001\001\000\002\001\001\000\002\001\001\000" +
    "\004\042\210\001\001\000\004\042\152\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\004\067" +
    "\141\001\001\000\004\047\142\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\004\042\207\001\001\000\004\042\205" +
    "\001\001\000\002\001\001\000\002\001\001\000\004\042" +
    "\167\001\001\000\004\042\166\001\001\000\004\042\165" +
    "\001\001\000\004\042\164\001\001\000\004\042\163\001" +
    "\001\000\022\030\162\031\130\032\127\033\125\034\120" +
    "\035\117\037\121\041\116\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\004\036" +
    "\175\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\004\036\201\001\001\000\002" +
    "\001\001\000\002\001\001\000\004\036\204\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\022\030\212\031\130\032" +
    "\127\033\125\034\120\035\117\037\121\041\116\001\001" +
    "\000\004\040\213\001\001\000\002\001\001\000\022\030" +
    "\215\031\130\032\127\033\125\034\120\035\117\037\121" +
    "\041\116\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\022\030\222\031\130" +
    "\032\127\033\125\034\120\035\117\037\121\041\116\001" +
    "\001\000\002\001\001\000\004\042\233\001\001\000\004" +
    "\036\231\001\001\000\002\001\001\000\002\001\001\000" +
    "\004\042\230\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\004\042\236\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\010\017\250\020\245\046\247\001\001" +
    "\000\010\017\255\020\245\046\247\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\006\021\252" +
    "\043\113\001\001\000\004\061\253\001\001\000\004\047" +
    "\254\001\001\000\002\001\001\000\002\001\001\000\006" +
    "\005\262\006\261\001\001\000\002\001\001\000\002\001" +
    "\001\000\006\005\263\006\261\001\001\000\002\001\001" +
    "\000\002\001\001\000\004\007\267\001\001\000\002\001" +
    "\001\000\002\001\001\000\004\053\271\001\001\000\002" +
    "\001\001\000\004\047\272\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001" });

  /** Access to <code>reduce_goto</code> table. */
  public short[][] reduce_table() {return _reduce_table;}

  /** Instance of action encapsulation class. */
  protected CUP$parser$actions action_obj;

  /** Action encapsulation object initializer. */
  protected void init_actions()
    {
      action_obj = new CUP$parser$actions(this);
    }

  /** Invoke a user supplied parse action. */
  public java_cup.runtime.Symbol do_action(
    int                        act_num,
    java_cup.runtime.lr_parser parser,
    java.util.Stack            stack,
    int                        top)
    throws java.lang.Exception
  {
    /* call code in generated class */
    return action_obj.CUP$parser$do_action(act_num, parser, stack, top);
  }

  /** Indicates start state. */
  public int start_state() {return 0;}
  /** Indicates start production. */
  public int start_production() {return 0;}

  /** <code>EOF</code> Symbol index. */
  public int EOF_sym() {return 0;}

  /** <code>error</code> Symbol index. */
  public int error_sym() {return 1;}



	SyntaxErrorManager syntaxErrorManager = CompilerContext.getSyntaxErrorManager();
	
	public void syntax_error(Symbol symbol)
	{ 
	    Token token = (Token) symbol.value;
	    syntaxErrorManager.syntaxError ("Error sintactico", token);	    
	}
		
	public void unrecovered_syntax_error(java_cup.runtime.Symbol symbol)
	{	
	    Token token = (Token) symbol.value;
	    syntaxErrorManager.syntaxFatalError ("Error fatal", token);
	}

}

/** Cup generated class to encapsulate user supplied action code.*/
class CUP$parser$actions {


	
	SyntaxErrorManager   syntaxErrorManager   = CompilerContext.getSyntaxErrorManager();
	SemanticErrorManager semanticErrorManager = CompilerContext.getSemanticErrorManager ();
	ScopeManagerIF       scopeManager         = CompilerContext.getScopeManager ();
	FinalCodeFactoryIF   finalCodeFactory     = CompilerContext.getFinalCodeFactory ();

	// Cadenas 
	List cadenas = new ArrayList();
	// Desplazamiento con RA principal
	int despl=0;

	// Desplazamiento x ambito
	HashMap desplScope = new HashMap(); 


  private final parser parser;

  /** Constructor */
  CUP$parser$actions(parser parser) {
    this.parser = parser;
  }

  /** Method with the actual generated action code. */
  public final java_cup.runtime.Symbol CUP$parser$do_action(
    int                        CUP$parser$act_num,
    java_cup.runtime.lr_parser CUP$parser$parser,
    java.util.Stack            CUP$parser$stack,
    int                        CUP$parser$top)
    throws java.lang.Exception
    {
      /* Symbol object for return from actions */
      java_cup.runtime.Symbol CUP$parser$result;

      /* select the action based on the action number */
      switch (CUP$parser$act_num)
        {
          /*. . . . . . . . . . . . . . . . . . . .*/
          case 114: // ntPtoComa ::= TPTOCOMA ntPtoComa 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("ntPtoComa",37, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 113: // ntPtoComa ::= TPTOCOMA 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("ntPtoComa",37, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 112: // finalModulo ::= error 
            {
              BloqueSentencias RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("finalModulo",35, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 111: // finalModulo ::= sentencias TEND TIDENTIFICADOR NT$15 ntPtoComa 
            {
              BloqueSentencias RESULT =null;
              // propagate RESULT from NT$15
                RESULT = (BloqueSentencias) ((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int bloqueleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).left;
		int bloqueright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).right;
		BloqueSentencias bloque = (BloqueSentencias)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-4)).value;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("finalModulo",35, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 110: // NT$15 ::= 
            {
              BloqueSentencias RESULT =null;
		int bloqueleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int bloqueright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		BloqueSentencias bloque = (BloqueSentencias)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;

                    RESULT = bloque;
                
              CUP$parser$result = parser.getSymbolFactory().newSymbol("NT$15",53, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 109: // cuerpoModulo ::= error 
            {
              BloqueSentencias RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("cuerpoModulo",34, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 108: // cuerpoModulo ::= ctes tipos vars subs TBEGIN finalModulo 
            {
              BloqueSentencias RESULT =null;
		int bloqueleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int bloqueright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		BloqueSentencias bloque = (BloqueSentencias)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
            RESULT = bloque;
        
              CUP$parser$result = parser.getSymbolFactory().newSymbol("cuerpoModulo",34, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 107: // varSeqDeIds ::= TIDENTIFICADOR TCOMA varSeqDeIds 
            {
              Lista RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Token id = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int listleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int listright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Lista list = (Lista)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
                    Lista lista = new Lista();

                    for(int i=0; i < list.size(); i++) {
                        lista.add(list.get(i));
                    }

                    String varName = id.getLexema();

                    Var var = new Var();
                    var.setName(varName);

                    lista.add(var);

                    RESULT = lista;
                
              CUP$parser$result = parser.getSymbolFactory().newSymbol("varSeqDeIds",36, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 106: // varSeqDeIds ::= TIDENTIFICADOR 
            {
              Lista RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Token id = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 
                    String varName = id.getLexema();

                    Var var = new Var();

                    var.setName(varName);
                    var.setColumn(id.getColumn());
                    Lista lista = new Lista();

                    lista.add(var);

                    RESULT = lista;
                
              CUP$parser$result = parser.getSymbolFactory().newSymbol("varSeqDeIds",36, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 105: // tipoPrimitivo ::= TBOOLEAN 
            {
              String RESULT =null;
		int boolleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int boolright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Token bool = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 RESULT = "BOOLEAN"; 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("tipoPrimitivo",33, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 104: // tipoPrimitivo ::= TINTEGER 
            {
              String RESULT =null;
		int integerleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int integerright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Token integer = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 RESULT = "INTEGER"; 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("tipoPrimitivo",33, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 103: // expresion ::= error 
            {
              Expresion RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("expresion",32, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 102: // expresion ::= TIDENTIFICADOR TPARI sentCallParams TPARD 
            {
              Expresion RESULT =null;
		

        
              CUP$parser$result = parser.getSymbolFactory().newSymbol("expresion",32, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 101: // expresion ::= TIDENTIFICADOR TPUNTO TIDENTIFICADOR 
            {
              Expresion RESULT =null;
		int id1left = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int id1right = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Token id1 = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int id2left = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int id2right = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Token id2 = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
            if ( !(scopeManager.containsSymbol(id1.getLexema() + id2.getLexema())) ) {
                semanticErrorManager.semanticFatalError ("El tipo registro: " + id1.getLexema() +" en [" + id1.getLine() + ":" + id1.getColumn() + "] no ha sido definida.");
            }

            ScopeIF scope = scopeManager.getCurrentScope();
            //SymbolIF simbolo = scopeManager.searchSymbol(id1.getLexema());

            TypeRecord tipoRecord = (TypeRecord) scopeManager.searchType(id1.getLexema());

            // El campo existe en el registro id1
            if (! tipoRecord.containsCampo(id2.getLexema() )) {
                semanticErrorManager.semanticFatalError ("El campo registro: " + id2.getLexema() +" en [" + id2.getLine() + ":" + id2.getColumn() + "] no ha sido definida.");
            }

/*             Expresion e = new Expresion(tipoRecord.getTypeCampo(id2.getLexema()), id2.getLine(), id2.getColumn());
            HashMap tablaCampos = tipoRecord.getTablaCampos();
            SymbolVariable simboloCampo = (SymbolVariable) tablaCampos.get(id2.getLexema()); 
            //Obtener la posición que ocupa el campo id2 dentro del registro id1
            
            //Código intermedio
            TemporalFactory tF = new TemporalFactory(scope);
            IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scope); 
            TemporalIF temp = tF.create();
            TemporalIF temp1 = tF.create();
            TemporalIF temp2 = tF.create();
            TemporalIF temp3 = tF.create();
            SymbolIF sV = scopeManager.searchSymbol(id1.getLexema());
            Variable var = new Variable(id1.getLexema(), sV.getScope()); 
            
            cb.addQuadruple("MVA", temp1, var); //dirección base de la variable 
            cb.addQuadruple("MV", temp2, 1); //desplazamiento
            cb.addQuadruple("ADD", temp3, temp1, temp2);
            cb.addQuadruple("MVP", temp, temp3);
            e.setTemporal(temp);
            e.setIntermediateCode (cb.create());

            RESULT = e; */

                SymbolIF simbolo = scopeManager.searchSymbol(id1.getLexema() + id2.getLexema());
                Expresion exp = new Expresion(simbolo.getType(), id2.getLine(), id2.getColumn());
                
                if (simbolo instanceof SymbolConstant) {
					SymbolConstant simboloCte = (SymbolConstant) simbolo;
					Value valor = new Value(simboloCte.getValue());
                    exp.setResultado(valor);
                } else {
                    Variable var = new Variable(id1.getLexema() + id2.getLexema(), scope);
                    var.setAmbito(simbolo.getScope());
                    exp.setReferencia(true);
                    exp.setResultado(var);
                }
                RESULT = exp;

        
              CUP$parser$result = parser.getSymbolFactory().newSymbol("expresion",32, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 100: // expresion ::= TIDENTIFICADOR 
            {
              Expresion RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Token id = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		  //esto debería estar terminado asi
            ScopeIF scope = scopeManager.getCurrentScope();
            SymbolTableIF tablaSimbolos = scope.getSymbolTable();
            TypeTableIF tablaTipos = scope.getTypeTable();
            
            if (!(scopeManager.containsSymbol(id.getLexema()))) {
                semanticErrorManager.semanticFatalError ("La variable: " + id.getLexema() +" en [" + id.getLine() + ":" + id.getColumn() + "] no ha sido definida.");
            } else {
                SymbolIF simbolo = scopeManager.searchSymbol(id.getLexema());
                Expresion exp = new Expresion(simbolo.getType(), id.getLine(), id.getColumn());
                
                if (simbolo instanceof SymbolConstant) {
					SymbolConstant simboloCte = (SymbolConstant) simbolo;
					Value valor = new Value(simboloCte.getValue());
                    exp.setResultado(valor);
                } else {
                    Variable var = new Variable(id.getLexema(), scope);
                    var.setAmbito(simbolo.getScope());
                    exp.setReferencia(true);
                    exp.setResultado(var);
                }
                RESULT = exp;
            }
        
              CUP$parser$result = parser.getSymbolFactory().newSymbol("expresion",32, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 99: // expresion ::= TLFALSE 
            {
              Expresion RESULT =null;
		int falseValueleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int falseValueright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Token falseValue = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		     //listo
            ScopeIF scope = scopeManager.getCurrentScope();
            TemporalFactoryIF tf = new TemporalFactory(scope);
            IntermediateCodeBuilderIF cb = new IntermediateCodeBuilder(scope);

            Expresion expresion = new Expresion(scopeManager.searchType("BOOLEAN"), falseValue.getLine(), falseValue.getColumn());
            
            // Le damos el valor true=1 y false=0
            Value resultado = new Value(0);

            TemporalIF temp = tf.create();
            
            cb.addQuadruple("MV", temp, resultado);

            expresion.setTemporal(temp);
            expresion.setTipo(scopeManager.searchType("BOOLEAN"));
            // expresion.setResultado(resultado);

            RESULT = expresion;
        
              CUP$parser$result = parser.getSymbolFactory().newSymbol("expresion",32, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 98: // expresion ::= TLTRUE 
            {
              Expresion RESULT =null;
		int trueValueleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int trueValueright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Token trueValue = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		       //listo
            ScopeIF scope = scopeManager.getCurrentScope();
            TemporalFactoryIF tf = new TemporalFactory(scope);
            IntermediateCodeBuilderIF cb = new IntermediateCodeBuilder(scope);

            Expresion expresion = new Expresion(scopeManager.searchType("BOOLEAN"), trueValue.getLine(), trueValue.getColumn());
            
            // Le damos el valor true=1 y false=0
            Value resultado = new Value(1);

            TemporalIF temp = tf.create();
            
            cb.addQuadruple("MV", temp, resultado);

            expresion.setTemporal(temp);
            expresion.setTipo(scopeManager.searchType("BOOLEAN"));
            // expresion.setResultado(resultado);

            RESULT = expresion;
        
              CUP$parser$result = parser.getSymbolFactory().newSymbol("expresion",32, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 97: // expresion ::= TLINT 
            {
              Expresion RESULT =null;
		int numleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int numright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Token num = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		   
            ScopeIF scope = scopeManager.getCurrentScope();
            Expresion exp = new Expresion(scopeManager.searchType("INTEGER"), num.getLine(), num.getColumn());
            Value resultado=new Value(Integer.parseInt(num.getLexema()));
            exp.setResultado(resultado);  // Guardamos el valor operador
            RESULT = exp;
        
              CUP$parser$result = parser.getSymbolFactory().newSymbol("expresion",32, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 96: // expresion ::= expresion TDISTINTO expresion 
            {
              Expresion RESULT =null;
		int exp1left = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int exp1right = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Expresion exp1 = (Expresion)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Token id = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int exp2left = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int exp2right = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Expresion exp2 = (Expresion)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
            //comprobamos todo tipos y demas
             if ( !(exp1.getTipo() == exp2.getTipo())  ||  !(exp1.getTipo().getName().equals("INTEGER"))  || !(exp2.getTipo().getName().equals("INTEGER")) )  {
                semanticErrorManager.semanticFatalError ("232. La expresion: " + id.getLexema() +" en [" + id.getLine() + ":" + id.getColumn() + "] no es del mismo tipo.");
			} else {
                if (exp1.getTipo()!=null && exp2.getTipo()!=null){
                    if (!exp1.getTipo().getName().toString().equals("INTEGER") || !exp2.getTipo().getName().toString().equals("INTEGER")){
                        semanticErrorManager.semanticFatalError ("3 Una expresion logica debe usar tipos enteros con el operador: " + id.getLexema() + " [" + id.getLine() + ":" + id.getColumn() + "].");
                    } else {
                        
                        if ( !(exp1.getTipo() == exp2.getTipo()) )
                                  semanticErrorManager.semanticFatalError ("238. La expresion: " + id.getLexema() +" en [" + 
							id.getLine() + ":" + id.getColumn() + "] no es del mismo tipo.");
                            if ( (exp1.getTipo() instanceof TypeRecord) || exp1.getTipo() instanceof TypeSet )
                                  semanticErrorManager.semanticFatalError ("La expresion: " + id.getLexema() +" en [" + 
							id.getLine() + ":" + id.getColumn() + "] no permitida para este tipo.");
                     
                            Expresion exp = new Expresion(scopeManager.searchType("BOOLEAN"), id.getLine(), id.getColumn());
                            ScopeIF scope = scopeManager.getCurrentScope();
                            
                            TemporalFactoryIF tf = new TemporalFactory(scope);  //cambiado
                            Temporal temporal = (Temporal) tf.create(); 
                            temporal.setDesplazamiento(despl);
                            despl++;
                            
                            IntermediateCodeBuilderIF cb = new IntermediateCodeBuilder(scope);
                            List code1 = exp1.getIntermediateCode();
                            List code2 = exp2.getIntermediateCode();
                            cb.addQuadruples (code1);
                            cb.addQuadruples (code2);
                            Value verdad = new Value(1);
                            Value falso = new Value(0);
                
                            LabelFactory lf = new LabelFactory(scope.getName());
                            LabelIF LTRUE = lf.create();
                            LabelIF LFIN = lf.create();
                            cb.addQuadruple ("CMP", exp1.getResultado(), exp2.getResultado()); 
                            cb.addQuadruple ("BNZ", LTRUE); 
                            cb.addQuadruple ("ASIGNACION", temporal, falso);
                            cb.addQuadruple ("BR", LFIN);
                            cb.addQuadruple ("LABEL", LTRUE);
                            cb.addQuadruple ("ASIGNACION", temporal, verdad);
                            cb.addQuadruple ("LABEL", LFIN);

                            List code=cb.create ();
                            exp.setResultado (temporal); 
                            exp.setIntermediateCode (code); 
                            
                            exp.setTipo(scopeManager.searchType("BOOLEAN")); //esto es mio!!!

                            RESULT=exp;
                    }
                }
            }
        
              CUP$parser$result = parser.getSymbolFactory().newSymbol("expresion",32, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 95: // expresion ::= expresion TMENOR expresion 
            {
              Expresion RESULT =null;
		int exp1left = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int exp1right = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Expresion exp1 = (Expresion)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Token id = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int exp2left = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int exp2right = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Expresion exp2 = (Expresion)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 /*comparaciones*/
            //comprobamos todo tipos y demas
             if ( !(exp1.getTipo() == exp2.getTipo())  ||  !(exp1.getTipo().getName().equals("INTEGER"))  || !(exp2.getTipo().getName().equals("INTEGER")) )  {
                semanticErrorManager.semanticFatalError ("232. La expresion: " + id.getLexema() +" en [" + id.getLine() + ":" + id.getColumn() + "] no es del mismo tipo.");
			}
                Expresion exp = new Expresion(scopeManager.searchType("BOOLEAN"), id.getLine(), id.getColumn());
                ScopeIF scope = scopeManager.getCurrentScope();
				//   TemporalFactoryIF tf = CompilerContext.getTemporalFactory(scope);			
                TemporalFactory tf = new TemporalFactory (scope);
	
                Temporal temporal = (Temporal) tf.create(); 
                temporal.setDesplazamiento(despl);
                despl++;
                IntermediateCodeBuilderIF cb = new IntermediateCodeBuilder(scope);
                List code1 = exp1.getIntermediateCode();
                List code2 = exp2.getIntermediateCode();
                cb.addQuadruples (code1);
                cb.addQuadruples (code2);
                Value verdad = new Value(1);
                Value falso = new Value(0);
                //   LabelFactoryIF lf = CompilerContext.getLabelFactory();	
                LabelFactory lf= new LabelFactory(scope.getName());
				
                LabelIF LTRUE = lf.create();
                LabelIF LFIN = lf.create();				
                // Hacemos cmp al reves para contemplar caso ambos iguales
                cb.addQuadruple ("CMP", exp1.getResultado(), exp2.getResultado()); 
                cb.addQuadruple ("BN", LTRUE); 
                cb.addQuadruple ("ASIGNACION", temporal, falso);
                cb.addQuadruple ("BR", LFIN);
                cb.addQuadruple ("LABEL", LTRUE);
                cb.addQuadruple ("ASIGNACION", temporal, verdad);
                cb.addQuadruple ("LABEL", LFIN);
                                
                List code=cb.create ();
                exp.setResultado (temporal); 
                exp.setIntermediateCode (code); 

                exp.setTipo(scopeManager.searchType("BOOLEAN"));

				RESULT=exp;
               
        
              CUP$parser$result = parser.getSymbolFactory().newSymbol("expresion",32, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 94: // expresion ::= expresion TAND expresion 
            {
              Expresion RESULT =null;
		int exp1left = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int exp1right = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Expresion exp1 = (Expresion)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Token id = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int exp2left = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int exp2right = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Expresion exp2 = (Expresion)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
            if ( !(exp1.getTipo() == exp2.getTipo()) || !(exp1.getTipo().getName().equals("BOOLEAN")) || !(exp2.getTipo().getName().equals("BOOLEAN")) ) {
                System.out.println(exp1.getTipo().getName());
                                System.out.println(exp2.getTipo().getName());

                semanticErrorManager.semanticFatalError ("228. La expresion: " + id.getLexema() +" en [" + id.getLine() + ":" + id.getColumn() + "] no es del mismo tipo.");
            } else {
                if (exp1.getTipo()!=null && exp2.getTipo()!=null){
                    if (!exp1.getTipo().getName().toString().equals("BOOLEAN") || !exp2.getTipo().getName().toString().equals("BOOLEAN")){
                      semanticErrorManager.semanticFatalError ("2 Una expresiOn lOgica debe usar tipos enteros con el operador: " + id.getLexema() + " [" + id.getLine() + ":" + id.getColumn() + "].");
                    } else {
                        //MEMORIA: Considero l�gica de cortocircuito. Adem�s <=0 es falso, y el resto verdadero.
                        Expresion exp = new Expresion (scopeManager.searchType("INTEGER"), id.getLine(), id.getColumn());
                        ScopeIF scope = scopeManager.getCurrentScope();
                        TemporalFactory tf = new TemporalFactory (scope);
                        LabelFactory labelFactory= new LabelFactory(scope.getName());

                        // Integer numTemporal=scopeManager.getScope().getTemporalTable().getTemporals().size();
                        // Integer posTemp=numTemporal+despl;
                        TemporalIF t = tf.create();
                        // t.setDesplazamiento(posTemp);
                        LabelIF lTrue = labelFactory.create ("TRUE");
                        LabelIF lFalse = labelFactory.create ("FALSE");
                        IntermediateCodeBuilder cb=new IntermediateCodeBuilder (scope);
                        cb.addQuadruples (exp1.getIntermediateCode());
                        cb.addQuadruples (exp2.getIntermediateCode());
                        //Cortocircuito, if a then b else false
                        Value Verdadero=new Value(1);
                        Value Falso=new Value(0);

                        cb.addQuadruple ("CMP", Verdadero, exp1.getResultado()); //compara
                        cb.addQuadruple ("BN",lTrue); //salto negativo
                        cb.addQuadruple ("ASIGNACION", t, exp2.getResultado());
                        cb.addQuadruple ("BR",lFalse);//salto incondicional
                        cb.addQuadruple ("LABEL",lTrue);
                        cb.addQuadruple ("ASIGNACION", t, Falso);
                        cb.addQuadruple ("LABEL",lFalse);
                        exp.setIntermediateCode(cb.create());
                        exp.setResultado(t);

                        exp.setTipo(scopeManager.searchType("BOOLEAN"));

                        RESULT = exp;                            
                    }
                }
            }
        
              CUP$parser$result = parser.getSymbolFactory().newSymbol("expresion",32, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 93: // expresion ::= expresion TSUMA expresion 
            {
              Expresion RESULT =null;
		int exp1left = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int exp1right = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Expresion exp1 = (Expresion)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Token id = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int exp2left = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int exp2right = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Expresion exp2 = (Expresion)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
            if ( !(exp1.getTipo() == exp2.getTipo())  ||  !(exp1.getTipo().getName().equals("INTEGER"))  || !(exp2.getTipo().getName().equals("INTEGER")) )  {
                semanticErrorManager.semanticFatalError ("La expresion: " + id.getLexema() +" en [" + id.getLine() + ":" + id.getColumn() + "] no es del mismo tipo.");
			} else {
                ScopeIF scope = scopeManager.getCurrentScope();
                IntermediateCodeBuilderIF cb = new IntermediateCodeBuilder(scope);
                Expresion exp = new Expresion(scopeManager.searchType("INTEGER"), id.getLine(), id.getColumn());

                TemporalFactoryIF tf = new TemporalFactory(scope); 

                Temporal temporal = (Temporal) tf.create(); 
                
                if (exp.castingTipos(exp1 , exp2) ){
                    semanticErrorManager.semanticFatalError ("La expresion: " + id.getLexema() +" en [" + id.getLine() + ":" + id.getColumn() + "] no es del mismo tipo.");
                }

                temporal.setDesplazamiento(despl);
                despl++;
                List code1 = exp1.getIntermediateCode();
                List code2 = exp2.getIntermediateCode();
                cb.addQuadruples (code1);
                cb.addQuadruples (code2);
                cb.addQuadruple ("ADD", temporal, exp1.getResultado(), exp2.getResultado());

                List code=cb.create ();
                exp.setResultado (temporal); 
                exp.setTipo(scopeManager.searchType("INTEGER"));
                exp.setIntermediateCode (code); 
                RESULT=exp;
            }
        
              CUP$parser$result = parser.getSymbolFactory().newSymbol("expresion",32, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 92: // expresion ::= expresion TDIVIDE expresion 
            {
              Expresion RESULT =null;
		int exp1left = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int exp1right = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Expresion exp1 = (Expresion)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Token id = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int exp2left = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int exp2right = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Expresion exp2 = (Expresion)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		/*aritmeticos*/
            if ( !(exp1.getTipo() == exp2.getTipo())  ||  !(exp1.getTipo().getName().equals("INTEGER"))  || !(exp2.getTipo().getName().equals("INTEGER")) )  {
                semanticErrorManager.semanticFatalError ("232. La expresion: " + id.getLexema() +" en [" + id.getLine() + ":" + id.getColumn() + "] no es del mismo tipo.");
			} else {
                Expresion exp = new Expresion(scopeManager.searchType("INTEGER"), id.getLine(), id.getColumn());
                if (exp.castingTipos(exp1 , exp2) ) {
                        semanticErrorManager.semanticFatalError ("222. La expresion: " + id.getLexema() +" en [" + id.getLine() + ":" + id.getColumn() + "] no es del mismo tipo.");
                }else{
                    ScopeIF scope = scopeManager.getCurrentScope();

                    TemporalFactoryIF tf = new TemporalFactory(scope); 
                    Temporal temporal = (Temporal) tf.create(); 
                    temporal.setDesplazamiento(despl);
                    despl++;
                    IntermediateCodeBuilderIF cb = new IntermediateCodeBuilder(scope);
                    List code1 = exp1.getIntermediateCode();
                    List code2 = exp2.getIntermediateCode();
                    cb.addQuadruples (code1);
                    cb.addQuadruples (code2);
                
                    cb.addQuadruple ("DIV", temporal, exp1.getResultado(), exp2.getResultado()); // temporal <- exp1 - exp2
                    List code=cb.create ();
                    exp.setResultado (temporal);    
                    exp.setIntermediateCode (code);  
                                            
                    RESULT=exp;
                }
            }
        
              CUP$parser$result = parser.getSymbolFactory().newSymbol("expresion",32, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 91: // expresion ::= TPARI expresion TPARD 
            {
              Expresion RESULT =null;
		int expresionleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int expresionright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Expresion expresion = (Expresion)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		    //listo
            RESULT = expresion;
        
              CUP$parser$result = parser.getSymbolFactory().newSymbol("expresion",32, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 90: // expresion ::= TNOT expresion 
            {
              Expresion RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Token id = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int expleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int expright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Expresion exp = (Expresion)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
            Expresion expresion = new Expresion (scopeManager.searchType("BOOLEAN"), id.getLine(), id.getColumn());

            if (exp.getTipo()!=null){
                if (!exp.getTipo().getName().toString().equals("BOOLEAN")){
                    semanticErrorManager.semanticFatalError ("1 Una expresiOn lOgica debe usar tipos LOGICOS con el operador: " + id.getLexema() + " [" + id.getLine() + ":" + id.getColumn() + "].");
                } else {
                    ScopeIF scope = scopeManager.getCurrentScope();
                    TemporalFactoryIF tF = new TemporalFactory(scope);
                    IntermediateCodeBuilderIF cb = new IntermediateCodeBuilder(scope);

                    TemporalIF temp1 = exp.getTemporal();
                    TemporalIF temp = tF.create();

                    cb.addQuadruples(exp.getIntermediateCode());
                    cb.addQuadruple("NOT", temp1, temp);
                    
                    expresion.setResultado(temp);
                    expresion.setIntermediateCode(cb.create());
                }
            }

            RESULT = expresion;
        
              CUP$parser$result = parser.getSymbolFactory().newSymbol("expresion",32, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 89: // sentCallParams ::= error 
            {
              Lista RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentCallParams",28, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 88: // sentCallParams ::= 
            {
              Lista RESULT =null;
		
            // BloqueSentencias bloque = new BloqueSentencias();
            RESULT = new Lista();


              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentCallParams",28, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 87: // sentCallParams ::= TIDENTIFICADOR TPUNTO TIDENTIFICADOR TCOMA sentCallParams 
            {
              Lista RESULT =null;
		int id1left = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).left;
		int id1right = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).right;
		Token id1 = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-4)).value;
		int id2left = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int id2right = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Token id2 = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int listleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int listright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Lista list = (Lista)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
            // BloqueSentencias bloque = new BloqueSentencias();
            Lista lista = new Lista();

            lista.add(id1.getLexema() + "." + id2.getLexema());
           
            for(int i =0; i < list.size(); i++) {//String id: list) {
                lista.add(list.get(i));
            }

            RESULT = lista;


              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentCallParams",28, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 86: // sentCallParams ::= TIDENTIFICADOR TPUNTO TIDENTIFICADOR 
            {
              Lista RESULT =null;
		int id1left = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int id1right = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Token id1 = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int id2left = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int id2right = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Token id2 = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
            // BloqueSentencias bloque = new BloqueSentencias();
            Lista lista = new Lista();

            lista.add(id1.getLexema() + "." + id2.getLexema());

            RESULT = lista;


              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentCallParams",28, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 85: // sentCallParams ::= TIDENTIFICADOR TCOMA sentCallParams 
            {
              Lista RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Token id = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int listleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int listright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Lista list = (Lista)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
            // BloqueSentencias bloque = new BloqueSentencias();
            Lista lista = new Lista();

            lista.add(id.getLexema());

            for(int i =0; i < list.size(); i++) {//String id: list) {
                lista.add(list.get(i));
            }

            RESULT = lista;


              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentCallParams",28, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 84: // sentCallParams ::= TIDENTIFICADOR 
            {
              Lista RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Token id = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
            // BloqueSentencias bloque = new BloqueSentencias();

            Lista lista = new Lista();

            lista.add(id.getLexema());

            RESULT = lista;


              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentCallParams",28, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 83: // sentCall ::= TIDENTIFICADOR 
            {
              BloqueSentencias RESULT =null;
		
            BloqueSentencias bloque = new BloqueSentencias();
            RESULT = bloque;


              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentCall",27, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 82: // sentCall ::= TIDENTIFICADOR TPARI sentCallParams TPARD 
            {
              BloqueSentencias RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).right;
		Token id = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-3)).value;
		int listaleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int listaright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Lista lista = (Lista)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		
            BloqueSentencias bloque = new BloqueSentencias();

            ScopeIF scope = scopeManager.getCurrentScope();
            SymbolTableIF symbolTable = scope.getSymbolTable();
            TypeTableIF typeTable = scope.getTypeTable();

            if(!symbolTable.containsSymbol(id.getLexema())) {
                semanticErrorManager.semanticFatalError("el simbolo " + id.getLexema() + " no es una funcion");
            }

            SymbolFunction symbolFunction = (SymbolFunction)symbolTable.getSymbol(id.getLexema());
            
            ArrayList<Parametro> parametros= symbolFunction.getParametros();

            if(symbolFunction instanceof SymbolFunction) {
                for(int i = 0; i < lista.size(); i++) {
                    String var = (String) lista.get(i);

                    if(!symbolTable.containsSymbol(var)) {
                        semanticErrorManager.semanticFatalError("el simbolo " + id.getLexema() + " no ha sido declarado previamente");
                    }

                    SymbolIF symbol = symbolTable.getSymbol(var);

                    String type = symbol.getType().getName();

                    if(!type.equals(parametros.get(i).getTipo().getName())) {
                        semanticErrorManager.semanticFatalError("el tipo de " + var + " no coincide con el del parametro");
                    }
                }
            }

            RESULT = bloque;


              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentCall",27, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 81: // sentReturn ::= TRETURN expresion 
            {
              BloqueSentencias RESULT =null;
		
            System.out.println("encontrada una sentencia de retorno");
            BloqueSentencias bloque = new BloqueSentencias();

            bloque.setTieneDevuelve(true);

            RESULT = bloque;
        
              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentReturn",26, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 80: // sentES ::= TWRITELN 
            {
              BloqueSentencias RESULT =null;
		
            BloqueSentencias bloqueSentencias = new BloqueSentencias ();
            bloqueSentencias.setTieneDevuelve(false);
            IntermediateCodeBuilder cb = new IntermediateCodeBuilder (scopeManager.getCurrentScope());
            cb.addQuadruple("WRTLN", null);
            bloqueSentencias.setIntermediateCode(cb.create());
            RESULT = bloqueSentencias;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentES",25, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 79: // sentES ::= TWRITEINT TPARI expresion TPARD 
            {
              BloqueSentencias RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).right;
		Token id = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-3)).value;
		int expleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int expright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Expresion exp = (Expresion)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		
            if (exp.getTipo()!=null){
                if (!exp.getTipo().getName().toString().equals("INTEGER")){
                    semanticErrorManager.semanticFatalError ("Una sentencia escribeEnt [" + id.getLine() + ":" + id.getColumn() + "] solo puede recibir variable o constante de tipo entero.");
                } else {
                    BloqueSentencias bloqueSentencias = new BloqueSentencias ();
                    IntermediateCodeBuilder cb = new IntermediateCodeBuilder (scopeManager.getCurrentScope());
                    cb.addQuadruples(exp.getIntermediateCode());
                                cb.addQuadruple("WRINT", exp.getResultado());
                    bloqueSentencias.setIntermediateCode(cb.create());
                    bloqueSentencias.setTieneDevuelve(false);
                    RESULT = bloqueSentencias;
                }
            }

              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentES",25, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 78: // sentES ::= TWRITESTRING TPARI TLSTRING TPARD 
            {
              BloqueSentencias RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).right;
		Token id = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-3)).value;
		int cadleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int cadright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Token cad = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		
            BloqueSentencias bloqueSentencias = new BloqueSentencias ();
            bloqueSentencias.setTieneDevuelve(false);
            IntermediateCodeBuilder cb = new IntermediateCodeBuilder (scopeManager.getCurrentScope());

            cadenas.add(cad.getLexema());

            cb.addQuadruple("WRSTR","cadena"+cadenas.size());
            bloqueSentencias.setIntermediateCode(cb.create());
            RESULT = bloqueSentencias;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentES",25, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 77: // sentElse ::= 
            {
              BloqueSentencias RESULT =null;
		
            BloqueSentencias bloque = new BloqueSentencias();
            RESULT = bloque;


              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentElse",30, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 76: // sentElse ::= TELSE sentencias 
            {
              BloqueSentencias RESULT =null;
		int sentleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int sentright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		BloqueSentencias sent = (BloqueSentencias)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
            // BloqueSentencias bloque = new BloqueSentencias();
            RESULT = sent;
        
              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentElse",30, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 75: // sentIf ::= TIF expresion TTHEN sentencias sentElse 
            {
              BloqueSentencias RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).right;
		Token id = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-4)).value;
		int expleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).left;
		int expright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).right;
		Expresion exp = (Expresion)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-3)).value;
		int sent1left = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int sent1right = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		BloqueSentencias sent1 = (BloqueSentencias)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int sent2left = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int sent2right = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		BloqueSentencias sent2 = (BloqueSentencias)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
            if ( !(exp.getTipo().getName().equals("BOOLEAN")) ) {
				semanticErrorManager.semanticFatalError("Error en " + id.getLexema() + ": la expresiOn no es de tipo boolean");
            }
                BloqueSentencias bloque = new BloqueSentencias();
				ScopeIF scope = scopeManager.getCurrentScope();
				IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scope);

                LabelFactory lf= new LabelFactory(scope.getName());

				LabelIF LTRUE = lf.create();
				LabelIF LFALSE = lf.create();

                cb.addQuadruples(exp.getIntermediateCode());
                cb.addQuadruple("CMP", exp.getResultado(), new Value(1));
				cb.addQuadruple("BNZ", LFALSE);
				cb.addQuadruples(sent1.getIntermediateCode());
				cb.addQuadruple("BR", LTRUE);
				cb.addQuadruple("LABEL", LFALSE);
				cb.addQuadruples(sent2.getIntermediateCode());
				cb.addQuadruple("LABEL", LTRUE);
                cb.addQuadruple("NOP", null);

                List code = cb.create();
                bloque.setIntermediateCode(code);
                RESULT=bloque;
        
              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentIf",29, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 74: // sentWhile ::= TWHILE expresion TDO sentencias 
            {
              BloqueSentencias RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).right;
		Token id = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-3)).value;
		int expleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int expright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Expresion exp = (Expresion)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int blqleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int blqright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		BloqueSentencias blq = (BloqueSentencias)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
                if(!(exp.getTipo().getName().toString().equals("BOOLEAN"))) {
					semanticErrorManager.semanticFatalError("Error en " + id.getLexema() + ": la expresiOn no es de tipo boolean");
                }

                BloqueSentencias bloque = new BloqueSentencias();
				ScopeIF scope = scopeManager.getCurrentScope();
				IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scope);

                LabelFactory lf = new LabelFactory(scope.getName());

				LabelIF LFALSE = lf.create();
				LabelIF LINICIO = lf.create();

                cb.addQuadruple("LABEL", LINICIO);
                cb.addQuadruples(exp.getIntermediateCode());
                cb.addQuadruple("CMP", exp.getResultado(), new Value(1));
				cb.addQuadruple("BNZ", LFALSE);   // Salto no cero
                cb.addQuadruples(blq.getIntermediateCode());
                cb.addQuadruple("BR", LINICIO);
                cb.addQuadruple("LABEL", LFALSE);

                bloque.setIntermediateCode(cb.create());

				RESULT = bloque;
            
              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentWhile",31, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 73: // sentAsign ::= TIDENTIFICADOR TPUNTO TIDENTIFICADOR TASSIGN expresion 
            {
              BloqueSentencias RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).right;
		Token id = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-4)).value;
		int campoleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int camporight = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Token campo = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int expleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int expright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Expresion exp = (Expresion)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 // asignación de registros
                /* String identificador = id.getLexema();

                BloqueSentencias bloque = new BloqueSentencias();

                ScopeIF scope = scopeManager.getCurrentScope();
                SymbolTableIF tablaSimbolos = scope.getSymbolTable();

                if(!tablaSimbolos.containsSymbol(identificador + campo.getLexema())) {
                    semanticErrorManager.semanticFatalError("No se encuentra el simbolo");
                } else {
                    TemporalFactoryIF tF = new TemporalFactory(scope); 
                    IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scope); 

                    TemporalIF temp = tF.create();
                    TemporalIF eTemp = exp.getTemporal();

                    cb.addQuadruples(exp.getIntermediateCode());
                    SymbolIF sV = scopeManager.searchSymbol(id.getLexema());
                    Variable var = new Variable(id.getLexema(), sV.getScope());
                    cb.addQuadruple("MVA", temp, var);
                    cb.addQuadruple("STP", temp, eTemp);
                    bloque.setIntermediateCode(cb.create());
                }

                RESULT = bloque; */

                String identificador = id.getLexema();
                ScopeIF scope = scopeManager.getCurrentScope();

                BloqueSentencias bloque = new BloqueSentencias();

                IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scope); 

                if (!(scopeManager.containsSymbol(identificador + campo.getLexema()))) {
                    semanticErrorManager.semanticFatalError ("La variable: " + identificador + campo.getLexema() +" en [" +  id.getLine() + ":" + id.getColumn() + "] no ha sido definida.");
                } else {
                    SymbolIF simbolo = scopeManager.searchSymbol(identificador+ campo.getLexema());
                    TypeIF tipo = simbolo.getType();

                    // Comprobamos que no es una constante
                    if (simbolo instanceof SymbolConstant) {
                        semanticErrorManager.semanticFatalError ("La constante: " + id.getLexema() +" en [" +  id.getLine() + ":" + id.getColumn() + "] no admite asignaciones.");
                    } else {
                        if(!tipo.getName().equals(exp.getTipo().getName())){
                            semanticErrorManager.semanticFatalError("Los tipos de la asignación no cuadran");
                        } else {
                            // TemporalFactoryIF tF = new TemporalFactory(scope); 
                            // TemporalIF temp = tF.create();
                            // TemporalIF eTemp = exp.getTemporal(); 
                            // cb.addQuadruples(exp.getIntermediateCode());
                            // SymbolIF sV = scopeManager.searchSymbol(id.getLexema());
                            // Variable var = new Variable(id.getLexema(), sV.getScope()); 
                            // cb.addQuadruple("MVA", temp, var);
                            // cb.addQuadruple("STP", temp, eTemp); 
                            // bloque.setIntermediateCode(cb.create());

                            // Creamos codigo para la sentencia 
                            Variable var = new Variable(id.getLexema() + campo.getLexema(), scope);
                            var.setAmbito(simbolo.getScope());
                            List code1 = exp.getIntermediateCode();
                            cb.addQuadruples(code1);
                            cb.addQuadruple("ASIGNACION", var, exp.getResultado());   

                            bloque.setIntermediateCode(cb.create());
                        }
                    }
                    
                    // else if (tipo instanceof TypeRecord) {
                    //     if ( !(tipo.getName() == exp.getTipo().getName()) ){       
                    //         semanticErrorManager.semanticFatalError ("284. La Asignacion: " + id.getLexema() +" en [" + id.getLine() + ":" + id.getColumn() + "] no coincide en tipos.");             
                    //     } else {
                            
                    //     }
                    // }

                }
                
                RESULT=bloque;

            
              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentAsign",24, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 72: // sentAsign ::= TIDENTIFICADOR TASSIGN expresion 
            {
              BloqueSentencias RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Token id = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int expleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int expright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Expresion exp = (Expresion)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		  //compobamos que está ya declarada, que no es una constante, que si es una función el tipo de retorno es igual al tipo de asignacion
                String identificador = id.getLexema();
                ScopeIF scope = scopeManager.getCurrentScope();

                BloqueSentencias bloque = new BloqueSentencias();

                IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scope); 

                if (!(scopeManager.containsSymbol(identificador))) {
                    semanticErrorManager.semanticFatalError ("La variable: " + identificador +" en [" +  id.getLine() + ":" + id.getColumn() + "] no ha sido definida.");
                } else {
                    SymbolIF simbolo = scopeManager.searchSymbol(identificador);
                    TypeIF tipo = simbolo.getType();

                    // Comprobamos que no es una constante
                    if (simbolo instanceof SymbolConstant) {
                        semanticErrorManager.semanticFatalError ("La constante: " + id.getLexema() +" en [" +  id.getLine() + ":" + id.getColumn() + "] no admite asignaciones.");
                    } else {
                        if(!tipo.getName().equals(exp.getTipo().getName())){
                            semanticErrorManager.semanticFatalError("Los tipos de la asignación no cuadran");
                        } else {
                            // Creamos codigo para la sentencia 
                            Variable var = new Variable(id.getLexema(), scope);
                            var.setAmbito(simbolo.getScope());
                            List code1 = exp.getIntermediateCode();
                            cb.addQuadruples(code1);
                            cb.addQuadruple("ASIGNACION", var, exp.getResultado());   

                            bloque.setIntermediateCode(cb.create());
                        }
                    }
                    
                    // else if (tipo instanceof TypeRecord) {
                    //     if ( !(tipo.getName() == exp.getTipo().getName()) ){       
                    //         semanticErrorManager.semanticFatalError ("284. La Asignacion: " + id.getLexema() +" en [" + id.getLine() + ":" + id.getColumn() + "] no coincide en tipos.");             
                    //     } else {
                            
                    //     }
                    // }

                }
                
                RESULT=bloque;
            
              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentAsign",24, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 71: // sent ::= error 
            {
              BloqueSentencias RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("sent",23, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 70: // sent ::= sentCall 
            {
              BloqueSentencias RESULT =null;
		int sentleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int sentright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		BloqueSentencias sent = (BloqueSentencias)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 RESULT = sent; 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("sent",23, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 69: // sent ::= sentWhile NT$14 TEND 
            {
              BloqueSentencias RESULT =null;
              // propagate RESULT from NT$14
                RESULT = (BloqueSentencias) ((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int sentleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int sentright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		BloqueSentencias sent = (BloqueSentencias)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("sent",23, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 68: // NT$14 ::= 
            {
              BloqueSentencias RESULT =null;
		int sentleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int sentright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		BloqueSentencias sent = (BloqueSentencias)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
 RESULT = sent; 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("NT$14",52, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 67: // sent ::= sentIf NT$13 TEND 
            {
              BloqueSentencias RESULT =null;
              // propagate RESULT from NT$13
                RESULT = (BloqueSentencias) ((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int sentleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int sentright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		BloqueSentencias sent = (BloqueSentencias)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("sent",23, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 66: // NT$13 ::= 
            {
              BloqueSentencias RESULT =null;
		int sentleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int sentright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		BloqueSentencias sent = (BloqueSentencias)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
 RESULT = sent; 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("NT$13",51, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 65: // sent ::= sentReturn 
            {
              BloqueSentencias RESULT =null;
		int sentleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int sentright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		BloqueSentencias sent = (BloqueSentencias)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 RESULT = sent; 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("sent",23, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 64: // sent ::= sentES 
            {
              BloqueSentencias RESULT =null;
		int sentleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int sentright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		BloqueSentencias sent = (BloqueSentencias)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 RESULT = sent; 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("sent",23, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 63: // sent ::= sentAsign 
            {
              BloqueSentencias RESULT =null;
		int sentleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int sentright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		BloqueSentencias sent = (BloqueSentencias)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 RESULT = sent; 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("sent",23, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 62: // sentencias ::= error 
            {
              BloqueSentencias RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentencias",22, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 61: // sentencias ::= 
            {
              BloqueSentencias RESULT =null;
		
            BloqueSentencias bloque = new BloqueSentencias();
            RESULT = bloque;


              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentencias",22, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 60: // sentencias ::= sent ntPtoComa sentencias 
            {
              BloqueSentencias RESULT =null;
		int sentleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int sentright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		BloqueSentencias sent = (BloqueSentencias)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int blqleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int blqright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		BloqueSentencias blq = (BloqueSentencias)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
                    BloqueSentencias bloque = new BloqueSentencias();

                    // si alguno de los bloques 
                    if (blq.getTieneDevuelve() || sent.getTieneDevuelve()) {
                        bloque.setTieneDevuelve(true);
                    }

                    IntermediateCodeBuilderIF cb = new IntermediateCodeBuilder (scopeManager.getCurrentScope());
                    cb.addQuadruples(sent.getIntermediateCode());
                    cb.addQuadruples(blq.getIntermediateCode());
                    List code = cb.create();
                    bloque.setIntermediateCode(code);
				
                	RESULT=bloque;
                
              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentencias",22, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 59: // subReturn ::= error 
            {
              String RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("subReturn",21, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 58: // subReturn ::= 
            {
              String RESULT =null;
		 RESULT = "noType"; 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("subReturn",21, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 57: // subReturn ::= TDOSPTS tipoPrimitivo 
            {
              String RESULT =null;
		int sleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int sright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Token s = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int tipoleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int tiporight = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		String tipo = (String)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 RESULT = tipo; 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("subReturn",21, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 56: // subPar ::= error 
            {
              Lista RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("subPar",20, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 55: // subPar ::= TVAR varSeqDeIds TDOSPTS varTipo 
            {
              Lista RESULT =null;
		int listaleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int listaright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Lista lista = (Lista)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int tipoleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int tiporight = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		String tipo = (String)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
            Lista list = (Lista) lista;

            Lista listaParametros = new Lista();

            for (int i = 0; i < list.size(); i++) {
                Var v = (Var) list.get(i);

                String name = v.getName();

                Parametro parametro = new Parametro();

                TypeIF tip = scopeManager.searchType(tipo);

                parametro.setNombre(name);
                parametro.setTipo(tip);
                parametro.setColumna(v.getColumn());

                listaParametros.add(parametro);
            }

            RESULT = listaParametros;

        
              CUP$parser$result = parser.getSymbolFactory().newSymbol("subPar",20, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 54: // subParamsCuerpo ::= subPar 
            {
              Lista RESULT =null;
		int listaParametrosleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int listaParametrosright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Lista listaParametros = (Lista)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
                    RESULT = listaParametros;
                 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("subParamsCuerpo",19, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 53: // subParamsCuerpo ::= subPar ntPtoComa subParamsCuerpo 
            {
              Lista RESULT =null;
		int listaParametrosleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int listaParametrosright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Lista listaParametros = (Lista)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int listaleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int listaright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Lista lista = (Lista)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 
                        for (int i = 0; i < listaParametros.size(); i++) {
                            lista.add(listaParametros.get(i));
                        }
                        
                        RESULT = lista;
                    
              CUP$parser$result = parser.getSymbolFactory().newSymbol("subParamsCuerpo",19, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 52: // subParams ::= 
            {
              Lista RESULT =null;
		 
                RESULT = new Lista(); 
            
              CUP$parser$result = parser.getSymbolFactory().newSymbol("subParams",18, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 51: // subParams ::= TPARI subParamsCuerpo NT$12 TPARD 
            {
              Lista RESULT =null;
              // propagate RESULT from NT$12
                RESULT = (Lista) ((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int listaleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int listaright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Lista lista = (Lista)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("subParams",18, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 50: // NT$12 ::= 
            {
              Lista RESULT =null;
		int listaleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int listaright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Lista lista = (Lista)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
 
                RESULT = lista; 
            
              CUP$parser$result = parser.getSymbolFactory().newSymbol("NT$12",50, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 49: // subParams ::= TPARI TPARD 
            {
              Lista RESULT =null;
		 
                RESULT = new Lista(); 
            
              CUP$parser$result = parser.getSymbolFactory().newSymbol("subParams",18, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 48: // subDecl ::= error 
            {
              SubDecl RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("subDecl",17, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 47: // subDecl ::= TIDENTIFICADOR subParams subReturn NT$11 ntPtoComa 
            {
              SubDecl RESULT =null;
              // propagate RESULT from NT$11
                RESULT = (SubDecl) ((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int identificadorleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).left;
		int identificadorright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).right;
		Token identificador = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-4)).value;
		int listaleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).left;
		int listaright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).right;
		Lista lista = (Lista)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-3)).value;
		int tipoleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int tiporight = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		String tipo = (String)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("subDecl",17, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 46: // NT$11 ::= 
            {
              SubDecl RESULT =null;
		int identificadorleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int identificadorright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Token identificador = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int listaleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int listaright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Lista lista = (Lista)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int tipoleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int tiporight = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		String tipo = (String)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;

                String nombreFuncion = identificador.getLexema();

                if (scopeManager.containsSymbol(nombreFuncion)) {
				    semanticErrorManager.semanticFatalError("350. La funcion "+identificador.getLexema()+" en la linea: "+identificador.getLine()+" ya ha sido declarada");
                } else {     
                    // Crear FUNCION en ambito
                    ScopeIF scope = scopeManager.getCurrentScope();
                    TypeTableIF tablaTipos = scope.getTypeTable();
                    SymbolTableIF tablaSimbolos = scope.getSymbolTable();

                    // a�adir funcion a TT
                    TypeFunction tipoFuncion = new TypeFunction(scope, nombreFuncion);
                    tablaTipos.addType(nombreFuncion, tipoFuncion);

                        				ArrayList parametros = new ArrayList(Utilidades.ordenaParametros(lista));

                    // aniadir funcion a TS
                    SymbolFunction simboloFunc = new SymbolFunction(scope, nombreFuncion, tablaTipos.getType(nombreFuncion));

                    simboloFunc.setParametros(parametros);

                    semanticErrorManager.semanticDebug("Aniadiendo el subprograma " + nombreFuncion + " a la tabla de simbolos");
                    tablaSimbolos.addSymbol(nombreFuncion, simboloFunc);            

                    SubDecl declaracion;

				    scopeManager.openScope(nombreFuncion); // NUEVO ambito para ser usado dentro funcion y tabla TS y TT

                    tablaTipos = scopeManager.getCurrentScope().getTypeTable();
				    tablaSimbolos = scopeManager.getCurrentScope().getSymbolTable();

                    if(tipo.equals("noType")) {  // el subprograma es un procedimiento
                        declaracion = new SubDecl(false);
                        tipoFuncion.setTipoRetorno(null);
                    } else {                     // es una funcion
                        declaracion = new SubDecl(true);
                        tipoFuncion.setTipoRetorno(scopeManager.searchType(tipo));  
                    }
                    
                    for (int i = 0; i < parametros.size(); i++) {
                        Parametro p = (Parametro) parametros.get(i);
                          
                        p.setReferencia(true); // en el tipo son todos por referencia

                        SymbolVariable simboloVar = new SymbolVariable (scopeManager.getCurrentScope(), p.getNombre(), p.getTipo());//, despl);
                        // despl++;
                        
                        // Creo lista ordenada de parametros en el PROCEDIMIENTO.
                        tipoFuncion.setTypeParametro(p.getColumna(), p.getTipo()); 

                        // Fijar paso parametros Ref/Valor en Symbolvar
                        simboloVar.setReferencia(p.getReferencia());
                        tablaSimbolos.addSymbol(p.getNombre(), simboloVar);                                  	
                        tipoFuncion.setParametro(simboloVar);
                    }

                    //////////////////
                    //cerramos ambito
                    scopeManager.closeScope();

                    RESULT = declaracion;
                }
            
              CUP$parser$result = parser.getSymbolFactory().newSymbol("NT$11",49, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 45: // subs ::= 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("subs",16, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 44: // subs ::= subs TPROCEDURE NT$10 subDecl cuerpoModulo 
            {
              Object RESULT =null;
              // propagate RESULT from NT$10
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int subDeclleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int subDeclright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		SubDecl subDecl = (SubDecl)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int bloqueleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int bloqueright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		BloqueSentencias bloque = (BloqueSentencias)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
            if((subDecl.getEsFuncion() && !bloque.getTieneDevuelve()) || (!subDecl.getEsFuncion() && bloque.getTieneDevuelve())) {
                semanticErrorManager.semanticFatalError("Esto no es una funcion. O falta el devuelve o no hay indicado el tipo del retorno");
            }

            RESULT = bloque;
        
              CUP$parser$result = parser.getSymbolFactory().newSymbol("subs",16, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 43: // NT$10 ::= 
            {
              Object RESULT =null;

            ScopeIF scope = scopeManager.getCurrentScope();

            semanticErrorManager.semanticDebug("Analizando los subprogramas del ambito " + scope.getName());

        
              CUP$parser$result = parser.getSymbolFactory().newSymbol("NT$10",48, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 42: // varTipo ::= TIDENTIFICADOR 
            {
              String RESULT =null;
		int tipoleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int tiporight = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Token tipo = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 RESULT = tipo.getLexema(); 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("varTipo",15, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 41: // varTipo ::= tipoPrimitivo 
            {
              String RESULT =null;
		int tipleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int tipright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		String tip = (String)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 RESULT = tip; 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("varTipo",15, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 40: // var ::= error 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("var",14, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 39: // var ::= varSeqDeIds TDOSPTS varTipo NT$9 ntPtoComa 
            {
              Object RESULT =null;
              // propagate RESULT from NT$9
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int listaleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).left;
		int listaright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).right;
		Lista lista = (Lista)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-4)).value;
		int tipoleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int tiporight = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		String tipo = (String)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("var",14, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 38: // NT$9 ::= 
            {
              Object RESULT =null;
		int listaleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int listaright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Lista lista = (Lista)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int tipoleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int tiporight = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		String tipo = (String)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;

            ScopeIF scope = scopeManager.getCurrentScope();
            TypeTableIF tablaTipos = scope.getTypeTable();
            SymbolTableIF tablaSimbolos = scope.getSymbolTable();
        
            if (!tablaTipos.containsType(tipo)) {
                semanticErrorManager.semanticFatalError("el tipo " + tipo + " no ha sido declarado");
            }

            for(int i = 0; i < lista.size(); i++) {
                Var v = (Var) lista.get(i);

                String name = v.getName();

                despl++;

                // comprobamos que la variable no ha sido declarada anteriormente y la guardamos en la tabla de simbolos
                if (!scope.getSymbolTable().containsSymbol(name) ){		
                    semanticErrorManager.semanticDebug("Anadiendo la variable " + name + " a la tabla de simbolos");
                    
                    SymbolVariable simboloVar = new SymbolVariable(scope, name, scopeManager.searchType(tipo), despl);
                    tablaSimbolos.addSymbol(name, simboloVar);                                       	
                } else {
                    semanticErrorManager.semanticFatalError ("210. La variable: " + name + " en [" + v.getLine() + ":" + v.getColumn() + "] ya ha sido definida.");
                }
            }

            RESULT = lista;

        
              CUP$parser$result = parser.getSymbolFactory().newSymbol("NT$9",47, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 37: // varsLista ::= var 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("varsLista",13, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 36: // varsLista ::= var varsLista 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("varsLista",13, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 35: // vars ::= 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("vars",12, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 34: // vars ::= TVAR NT$8 varsLista 
            {
              Object RESULT =null;
              // propagate RESULT from NT$8
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("vars",12, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 33: // NT$8 ::= 
            {
              Object RESULT =null;

            ScopeIF scope = scopeManager.getCurrentScope();

            semanticErrorManager.semanticDebug("Analizando las variables del ambito " + scope.getName());

        
              CUP$parser$result = parser.getSymbolFactory().newSymbol("NT$8",46, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 32: // regCampo ::= error 
            {
              CampoRegistro RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("regCampo",11, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 31: // regCampo ::= TIDENTIFICADOR TDOSPTS tipoPrimitivo NT$7 ntPtoComa 
            {
              CampoRegistro RESULT =null;
              // propagate RESULT from NT$7
                RESULT = (CampoRegistro) ((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).right;
		Token id = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-4)).value;
		int tipoleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int tiporight = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		String tipo = (String)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("regCampo",11, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 30: // NT$7 ::= 
            {
              CampoRegistro RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Token id = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int tipoleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int tiporight = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		String tipo = (String)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;

            String identificador = id.getLexema();
            TypeIF tipoPrimitivo = scopeManager.searchType(tipo);

            if(!tipo.equals("BOOLEAN") && !tipo.equals("INTEGER")) {
                semanticErrorManager.semanticFatalError ("210. El tipo en el registro : " + identificador + "[" + id.getLine() + ":" + id.getColumn() + "] no es bool o int.");
            }

            CampoRegistro reg = new CampoRegistro(identificador, tipoPrimitivo);

            RESULT = reg;
        
              CUP$parser$result = parser.getSymbolFactory().newSymbol("NT$7",45, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 29: // regCampos ::= regCampo 
            {
              Lista RESULT =null;
		int regleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int regright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		CampoRegistro reg = (CampoRegistro)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
            Lista lista = new Lista();
            lista.add(reg);
            RESULT = lista;
        
              CUP$parser$result = parser.getSymbolFactory().newSymbol("regCampos",10, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 28: // regCampos ::= regCampo regCampos 
            {
              Lista RESULT =null;
		int regleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int regright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		CampoRegistro reg = (CampoRegistro)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int listaleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int listaright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Lista lista = (Lista)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
                lista.add(reg);
                RESULT = lista;
            
              CUP$parser$result = parser.getSymbolFactory().newSymbol("regCampos",10, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 27: // registro ::= error 
            {
              Lista RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("registro",9, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 26: // registro ::= TRECORD regCampos NT$6 TEND 
            {
              Lista RESULT =null;
              // propagate RESULT from NT$6
                RESULT = (Lista) ((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int listaleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int listaright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Lista lista = (Lista)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("registro",9, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 25: // NT$6 ::= 
            {
              Lista RESULT =null;
		int listaleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int listaright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Lista lista = (Lista)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
 
            RESULT = lista; 
        
              CUP$parser$result = parser.getSymbolFactory().newSymbol("NT$6",44, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 24: // tipo ::= error 
            {
              TypeRecord RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("tipo",8, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 23: // tipo ::= TIDENTIFICADOR TIGUAL registro NT$5 ntPtoComa 
            {
              TypeRecord RESULT =null;
              // propagate RESULT from NT$5
                RESULT = (TypeRecord) ((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).right;
		Token id = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-4)).value;
		int listaleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int listaright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Lista lista = (Lista)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("tipo",8, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 22: // NT$5 ::= 
            {
              TypeRecord RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Token id = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int listaleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int listaright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Lista lista = (Lista)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;

            String identificador = id.getLexema();

            ScopeIF scope = scopeManager.getCurrentScope();
			TypeTableIF tablaTipos = scope.getTypeTable();

            SymbolTableIF tablaSimbolos = scope.getSymbolTable();

            //creamos un nuevo tipo registro
            TypeRecord tipoRegistro = new TypeRecord(scope, identificador);
            
            HashMap<String, CampoRegistro> campos = tipoRegistro.getTablaCampos();

            if (!scopeManager.containsType(identificador)) {
                semanticErrorManager.semanticDebug("Aniadiendo a la tabla de tipos el tipo " + identificador);

                tablaTipos.addType(tipoRegistro);
            } else {
                semanticErrorManager.semanticFatalError ("210. El tipo: " + identificador + " en [" + id.getLine() + ":" + id.getColumn() + "] ya ha sido definida.");
            }

            for(int i = 0; i < lista.size(); i++) {

                CampoRegistro campo = (CampoRegistro) lista.get(i);

                campos.put(campo.getName(), campo);

                despl++;
                
                SymbolVariable simboloVar = new SymbolVariable(scope, id.getLexema() + campo.getName(), campo.getTipo(), despl);
                tablaSimbolos.addSymbol(id.getLexema() + campo.getName(), simboloVar);
            }

            RESULT = tipoRegistro; //dado que el grupo A solo tiene los registros como tipos para crear todo tipo compuesto sera un registro

        
              CUP$parser$result = parser.getSymbolFactory().newSymbol("NT$5",43, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 21: // tiposLista ::= 
            {
              Lista RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("tiposLista",7, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 20: // tiposLista ::= tipo tiposLista 
            {
              Lista RESULT =null;
		int tipoleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int tiporight = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		TypeRecord tipo = (TypeRecord)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int listaleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int listaright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Lista lista = (Lista)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("tiposLista",7, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 19: // tipos ::= 
            {
              Lista RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("tipos",6, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 18: // tipos ::= TTYPE NT$4 tiposLista 
            {
              Lista RESULT =null;
              // propagate RESULT from NT$4
                RESULT = (Lista) ((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("tipos",6, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 17: // NT$4 ::= 
            {
              Lista RESULT =null;

            ScopeIF scope = scopeManager.getCurrentScope();

            semanticErrorManager.semanticDebug("Analizando los tipos del ambito " + scope.getName());

        
              CUP$parser$result = parser.getSymbolFactory().newSymbol("NT$4",42, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 16: // cteValor ::= TLINT 
            {
              Token RESULT =null;
		int enteroleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int enteroright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Token entero = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 RESULT=entero; 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("cteValor",5, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 15: // cteValor ::= TLFALSE 
            {
              Token RESULT =null;
		int boolleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int boolright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Token bool = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 RESULT=bool; 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("cteValor",5, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 14: // cteValor ::= TLTRUE 
            {
              Token RESULT =null;
		int boolleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int boolright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Token bool = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 RESULT=bool; 
              CUP$parser$result = parser.getSymbolFactory().newSymbol("cteValor",5, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 13: // cte ::= error 
            {
              Cte RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("cte",4, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 12: // cte ::= TIDENTIFICADOR TIGUAL cteValor NT$3 ntPtoComa 
            {
              Cte RESULT =null;
              // propagate RESULT from NT$3
                RESULT = (Cte) ((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).right;
		Token id = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-4)).value;
		int valueleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int valueright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Token value = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("cte",4, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 11: // NT$3 ::= 
            {
              Cte RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Token id = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int valueleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int valueright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Token value = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
 
            String identificador = id.getLexema();
            int val;

            ScopeIF scope = scopeManager.getCurrentScope();

            if (scope.getSymbolTable().containsSymbol(id.getLexema())) {
                semanticErrorManager.semanticFatalError("2La constante "+id.getLexema()+" en la linea: "+id.getLine()+" ya ha sido declarada");
            }

            String tipo = "BOOLEAN";

            if(value.getLexema().equals("TRUE")) {
                val = 1;
            } else if (value.getLexema().equals("FALSE")) {
                val = 0;
            } else { // integer
                val = Integer.parseInt(value.getLexema());
                tipo = "INTEGER";
            }

            SymbolTableIF tablaSimbolos = scope.getSymbolTable();
            SymbolConstant simboloCte = new SymbolConstant(scope,id.getLexema(),scopeManager.searchType(tipo),despl);
            tablaSimbolos.addSymbol(id.getLexema(), simboloCte);
            simboloCte.setValue(val);
 
            String typeOfValue = Utilidades.getTypeOfValue(value.getLexema());

            if (typeOfValue.equals("noValidType")) {
                semanticErrorManager.semanticFatalError("La constante " + identificador + " no tiene un tipo valido");
            }

            // RESULT = constante;
        
              CUP$parser$result = parser.getSymbolFactory().newSymbol("NT$3",41, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 10: // ctesLista ::= cte 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("ctesLista",3, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 9: // ctesLista ::= cte ctesLista 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("ctesLista",3, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 8: // ctes ::= 
            {
              Object RESULT =null;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("ctes",2, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 7: // ctes ::= TCONST NT$2 ctesLista 
            {
              Object RESULT =null;
              // propagate RESULT from NT$2
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;

              CUP$parser$result = parser.getSymbolFactory().newSymbol("ctes",2, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 6: // NT$2 ::= 
            {
              Object RESULT =null;
 
            ScopeIF scope = scopeManager.getCurrentScope();

            semanticErrorManager.semanticDebug("Analizando las constantes del ambito " + scope.getName());

        
              CUP$parser$result = parser.getSymbolFactory().newSymbol("NT$2",40, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 5: // axiom ::= TMODULE error 
            {
              Axiom RESULT =null;
		syntaxErrorManager.syntaxFatalError("001. No se ha especificado nombre al programa");
              CUP$parser$result = parser.getSymbolFactory().newSymbol("axiom",1, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 4: // axiom ::= TMODULE TIDENTIFICADOR ntPtoComa NT$1 cuerpoModulo 
            {
              Axiom RESULT =null;
              // propagate RESULT from NT$1
                RESULT = (Axiom) ((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).right;
		Token id = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-3)).value;
		int bloqueleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int bloqueright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		BloqueSentencias bloque = (BloqueSentencias)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
            ScopeIF scope = scopeManager.getCurrentScope();

            Axiom ax = new Ax();

            for (TemporalIF temp:scope.getTemporalTable().getTemporals()) {
                if (temp instanceof Temporal) {
                    ((Temporal) temp).setAddress(despl);
                    despl = despl + 1;
                }
            }

            int bloqueMainRA = 2;

            int tam;
            tam = scope.getSymbolTable().getSize() + scope.getTemporalTable().getSize() + bloqueMainRA;
            // TemporalIF temp = ax.getTemporal();

            IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scope);
            cb.addQuadruple("BEGIN", null, tam);
            cb.addQuadruples(bloque.getIntermediateCode());            
            cb.addQuadruple("HALT", null);

            // anyadimos todas las cadena al final del programa
            int i=1;
            cb.addQuadruple ("STRING", "cadena0","\"\\n\"", "");
            for (Iterator it = cadenas.iterator(); it.hasNext();i++){
                String nombre="cadena"+i;
                cb.addQuadruple ("STRING", nombre,it.next(), "");
            }

            List intermediateCode = cb.create();

            //IMPRIMIMOS CODIGO INTERMEDIO
            syntaxErrorManager.syntaxInfo("********************************************");
            syntaxErrorManager.syntaxInfo("**           CODIGO INTERMEDIO            **");
            syntaxErrorManager.syntaxInfo("********************************************");

            Iterator it = intermediateCode.iterator();
            while (it.hasNext()){
                syntaxErrorManager.syntaxInfo("** " + it.next().toString());
            }


            ax.setIntermediateCode(intermediateCode);

            RESULT = ax;

            //falta
        
              CUP$parser$result = parser.getSymbolFactory().newSymbol("axiom",1, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 3: // NT$1 ::= 
            {
              Axiom RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Token id = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
 
            String programName = id.getLexema();
            scopeManager.openScope(programName); 
  		
            ScopeIF scope = scopeManager.getCurrentScope();

			TypeTableIF tablaTipos = scope.getTypeTable();

            // aniadimos los tipos simples
            TypeSimple tipoBooleano = new TypeSimple(scope);
            tipoBooleano.setName("BOOLEAN");
			tablaTipos.addType(tipoBooleano);

			TypeSimple tipoEntero = new TypeSimple(scope);
            tipoEntero.setName("INTEGER");
            tablaTipos.addType(tipoEntero);
            
        
              CUP$parser$result = parser.getSymbolFactory().newSymbol("NT$1",39, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 2: // program ::= NT$0 axiom 
            {
              Object RESULT =null;
              // propagate RESULT from NT$0
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int axleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int axright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Axiom ax = (Axiom)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		 
  		// No modificar esta estructura, aunque se pueden añadir más acciones semánticas
  		
  		List intermediateCode = ax.getIntermediateCode ();
        finalCodeFactory.setEnvironment(CompilerContext.getExecutionEnvironment());
  		finalCodeFactory.create(intermediateCode);

  		// En caso de no comentarse las dos sentencias anteriores puede generar una excepcion
  		// en las llamadas a cupTest si el compilador no está completo. Esto es debido a que 
  		// aún no se tendrá implementada la generación de código intermedio ni final.
  		// Para la entrega final deberán descomentarse y usarse.
  		
  		syntaxErrorManager.syntaxInfo ("Parsing process ended.");
  
              CUP$parser$result = parser.getSymbolFactory().newSymbol("program",0, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 1: // NT$0 ::= 
            {
              Object RESULT =null;
 syntaxErrorManager.syntaxInfo ("Starting parsing..."); 
	
	
  
              CUP$parser$result = parser.getSymbolFactory().newSymbol("NT$0",38, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 0: // $START ::= program EOF 
            {
              Object RESULT =null;
		int start_valleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int start_valright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Object start_val = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		RESULT = start_val;
              CUP$parser$result = parser.getSymbolFactory().newSymbol("$START",0, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          /* ACCEPT */
          CUP$parser$parser.done_parsing();
          return CUP$parser$result;

          /* . . . . . .*/
          default:
            throw new Exception(
               "Invalid action number found in internal parse table");

        }
    }
}

